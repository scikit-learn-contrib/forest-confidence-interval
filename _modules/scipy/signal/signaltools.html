

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scipy.signal.signaltools &mdash; forestci 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="forestci 0.1.0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> forestci
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">forestci</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>scipy.signal.signaltools</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scipy.signal.signaltools</h1><div class="highlight"><pre>
<span></span><span class="c1"># Author: Travis Oliphant</span>
<span class="c1"># 1999 -- 2002</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">timeit</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">sigtools</span><span class="p">,</span> <span class="n">dlti</span>
<span class="kn">from</span> <span class="nn">._upfirdn</span> <span class="k">import</span> <span class="n">upfirdn</span><span class="p">,</span> <span class="n">_output_len</span>
<span class="kn">from</span> <span class="nn">scipy._lib.six</span> <span class="k">import</span> <span class="n">callable</span>
<span class="kn">from</span> <span class="nn">scipy._lib._version</span> <span class="k">import</span> <span class="n">NumpyVersion</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">fftpack</span><span class="p">,</span> <span class="n">linalg</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="p">(</span><span class="n">allclose</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span>
                   <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">atleast_2d</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">expand_dims</span><span class="p">,</span>
                   <span class="n">iscomplexobj</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span>
                   <span class="n">poly</span><span class="p">,</span> <span class="n">polyadd</span><span class="p">,</span> <span class="n">polyder</span><span class="p">,</span> <span class="n">polydiv</span><span class="p">,</span> <span class="n">polymul</span><span class="p">,</span> <span class="n">polysub</span><span class="p">,</span> <span class="n">polyval</span><span class="p">,</span>
                   <span class="n">product</span><span class="p">,</span> <span class="n">r_</span><span class="p">,</span> <span class="n">ravel</span><span class="p">,</span> <span class="n">real_if_close</span><span class="p">,</span> <span class="n">reshape</span><span class="p">,</span>
                   <span class="n">roots</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span>
                   <span class="n">zeros_like</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="k">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">.windows</span> <span class="k">import</span> <span class="n">get_window</span>
<span class="kn">from</span> <span class="nn">._arraytools</span> <span class="k">import</span> <span class="n">axis_slice</span><span class="p">,</span> <span class="n">axis_reverse</span><span class="p">,</span> <span class="n">odd_ext</span><span class="p">,</span> <span class="n">even_ext</span><span class="p">,</span> <span class="n">const_ext</span>
<span class="kn">from</span> <span class="nn">.filter_design</span> <span class="k">import</span> <span class="n">cheby1</span><span class="p">,</span> <span class="n">_validate_sos</span>
<span class="kn">from</span> <span class="nn">.fir_filter_design</span> <span class="k">import</span> <span class="n">firwin</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">minor</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">gcd</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">gcd</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;correlate&#39;</span><span class="p">,</span> <span class="s1">&#39;fftconvolve&#39;</span><span class="p">,</span> <span class="s1">&#39;convolve&#39;</span><span class="p">,</span> <span class="s1">&#39;convolve2d&#39;</span><span class="p">,</span> <span class="s1">&#39;correlate2d&#39;</span><span class="p">,</span>
           <span class="s1">&#39;order_filter&#39;</span><span class="p">,</span> <span class="s1">&#39;medfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;medfilt2d&#39;</span><span class="p">,</span> <span class="s1">&#39;wiener&#39;</span><span class="p">,</span> <span class="s1">&#39;lfilter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lfiltic&#39;</span><span class="p">,</span> <span class="s1">&#39;sosfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;deconvolve&#39;</span><span class="p">,</span> <span class="s1">&#39;hilbert&#39;</span><span class="p">,</span> <span class="s1">&#39;hilbert2&#39;</span><span class="p">,</span>
           <span class="s1">&#39;cmplx_sort&#39;</span><span class="p">,</span> <span class="s1">&#39;unique_roots&#39;</span><span class="p">,</span> <span class="s1">&#39;invres&#39;</span><span class="p">,</span> <span class="s1">&#39;invresz&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span>
           <span class="s1">&#39;residuez&#39;</span><span class="p">,</span> <span class="s1">&#39;resample&#39;</span><span class="p">,</span> <span class="s1">&#39;resample_poly&#39;</span><span class="p">,</span> <span class="s1">&#39;detrend&#39;</span><span class="p">,</span>
           <span class="s1">&#39;lfilter_zi&#39;</span><span class="p">,</span> <span class="s1">&#39;sosfilt_zi&#39;</span><span class="p">,</span> <span class="s1">&#39;sosfiltfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;choose_conv_method&#39;</span><span class="p">,</span>
           <span class="s1">&#39;filtfilt&#39;</span><span class="p">,</span> <span class="s1">&#39;decimate&#39;</span><span class="p">,</span> <span class="s1">&#39;vectorstrength&#39;</span><span class="p">]</span>


<span class="n">_modedict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

<span class="n">_boundarydict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fill&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;pad&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;circular&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;symm&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>


<span class="n">_rfft_mt_safe</span> <span class="o">=</span> <span class="p">(</span><span class="n">NumpyVersion</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s1">&#39;1.9.0.dev-e24486e&#39;</span><span class="p">)</span>

<span class="n">_rfft_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_valfrommode</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_modedict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable mode flags are &#39;valid&#39; (0),&quot;</span>
                             <span class="s2">&quot; &#39;same&#39; (1), or &#39;full&#39; (2).&quot;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">mode</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_bvalfromboundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_boundarydict</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable boundary flags are &#39;fill&#39;, &#39;wrap&#39;&quot;</span>
                             <span class="s2">&quot; (or &#39;circular&#39;), </span><span class="se">\n</span><span class="s2">  and &#39;symm&#39;&quot;</span>
                             <span class="s2">&quot; (or &#39;symmetric&#39;).&quot;</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">boundary</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If in &#39;valid&#39; mode, returns whether or not the input arrays need to be</span>
<span class="sd">    swapped depending on whether `shape1` is at least as large as `shape2` in</span>
<span class="sd">    every dimension.</span>

<span class="sd">    This is important for some of the correlation and convolution</span>
<span class="sd">    implementations in this module, where the larger array input needs to come</span>
<span class="sd">    before the smaller array input when operating in this mode.</span>

<span class="sd">    Note that if the mode provided is not &#39;valid&#39;, False is immediately</span>
<span class="sd">    returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
        <span class="n">ok1</span><span class="p">,</span> <span class="n">ok2</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape1</span><span class="p">,</span> <span class="n">shape2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d1</span> <span class="o">&gt;=</span> <span class="n">d2</span><span class="p">:</span>
                <span class="n">ok1</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d2</span> <span class="o">&gt;=</span> <span class="n">d1</span><span class="p">:</span>
                <span class="n">ok2</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ok1</span> <span class="ow">or</span> <span class="n">ok2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For &#39;valid&#39; mode, one must be at least &quot;</span>
                             <span class="s2">&quot;as large as the other in every dimension&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">ok1</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlate two N-dimensional arrays.</span>

<span class="sd">    Cross-correlate `in1` and `in2`, with the output size determined by the</span>
<span class="sd">    `mode` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear cross-correlation</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    method : str {&#39;auto&#39;, &#39;direct&#39;, &#39;fft&#39;}, optional</span>
<span class="sd">        A string indicating which method to use to calculate the correlation.</span>

<span class="sd">        ``direct``</span>
<span class="sd">           The correlation is determined directly from sums, the definition of</span>
<span class="sd">           correlation.</span>
<span class="sd">        ``fft``</span>
<span class="sd">           The Fast Fourier Transform is used to perform the correlation more</span>
<span class="sd">           quickly (only available for numerical arrays.)</span>
<span class="sd">        ``auto``</span>
<span class="sd">           Automatically chooses direct or Fourier method based on an estimate</span>
<span class="sd">           of which is faster (default).  See `convolve` Notes for more detail.</span>

<span class="sd">           .. versionadded:: 0.19.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlate : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        cross-correlation of `in1` with `in2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose_conv_method : contains more documentation on `method`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The correlation z of two d-dimensional arrays x and y is defined as::</span>

<span class="sd">        z[...,k,...] = sum[..., i_l, ...] x[..., i_l,...] * conj(y[..., i_l - k,...])</span>

<span class="sd">    This way, if x and y are 1-D arrays and ``z = correlate(x, y, &#39;full&#39;)`` then</span>

<span class="sd">    .. math::</span>

<span class="sd">          z[k] = (x * y)(k - N + 1)</span>
<span class="sd">               = \sum_{l=0}^{||x||-1}x_l y_{l-k+N-1}^{*}</span>

<span class="sd">    for :math:`k = 0, 1, ..., ||x|| + ||y|| - 2`</span>

<span class="sd">    where :math:`||x||` is the length of ``x``, :math:`N = \max(||x||,||y||)`,</span>
<span class="sd">    and :math:`y_m` is 0 when m is outside the range of y.</span>

<span class="sd">    ``method=&#39;fft&#39;`` only works for numerical arrays as it relies on</span>
<span class="sd">    `fftconvolve`. In certain cases (i.e., arrays of objects or when</span>
<span class="sd">    rounding integers can lose precision), ``method=&#39;direct&#39;`` is always used.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Implement a matched filter using cross-correlation, to recover a signal</span>
<span class="sd">    that has passed through a noisy channel.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; sig = np.repeat([0., 1., 1., 0., 1., 0., 0., 1.], 128)</span>
<span class="sd">    &gt;&gt;&gt; sig_noise = sig + np.random.randn(len(sig))</span>
<span class="sd">    &gt;&gt;&gt; corr = signal.correlate(sig_noise, np.ones(128), mode=&#39;same&#39;) / 128</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; clock = np.arange(64, len(sig), 128)</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_noise, ax_corr) = plt.subplots(3, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(clock, sig[clock], &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.plot(sig_noise)</span>
<span class="sd">    &gt;&gt;&gt; ax_noise.set_title(&#39;Signal with noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.plot(corr)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.plot(clock, corr[clock], &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.axhline(0.5, ls=&#39;:&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlated with rectangular pulse&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="p">)</span>

    <span class="c1"># Don&#39;t use _valfrommode, since correlate should not accept numeric modes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">_modedict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;same&#39;, or &#39;full&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># this either calls fftconvolve or this function with method==&#39;direct&#39;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">_reverse_and_conj</span><span class="p">(</span><span class="n">in2</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="c1"># fastpath to faster numpy.correlate for 1d inputs when possible</span>
    <span class="k">if</span> <span class="n">_np_conv_ok</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="c1"># _correlateND is far slower when in2.size &gt; in1.size, so swap them</span>
    <span class="c1"># and then undo the effect afterward if mode == &#39;full&#39;.  Also, it fails</span>
    <span class="c1"># with &#39;valid&#39; mode if in2 is larger than in1, so swap those, too.</span>
    <span class="c1"># Don&#39;t swap inputs for &#39;same&#39; mode, since shape of in1 matters.</span>
    <span class="n">swapped_inputs</span> <span class="o">=</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">in2</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span>
                      <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_correlateND</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>

        <span class="c1"># zero pad input</span>
        <span class="n">in1zpadded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="n">in1zpadded</span><span class="p">[</span><span class="n">sc</span><span class="p">]</span> <span class="o">=</span> <span class="n">in1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">z</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_correlateND</span><span class="p">(</span><span class="n">in1zpadded</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
        <span class="c1"># Reverse and conjugate to undo the effect of swapping inputs</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">_reverse_and_conj</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">z</span>


<span class="k">def</span> <span class="nf">_centered</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">newshape</span><span class="p">):</span>
    <span class="c1"># Return the center newshape portion of the array.</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">newshape</span><span class="p">)</span>
    <span class="n">currshape</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">startind</span> <span class="o">=</span> <span class="p">(</span><span class="n">currshape</span> <span class="o">-</span> <span class="n">newshape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">endind</span> <span class="o">=</span> <span class="n">startind</span> <span class="o">+</span> <span class="n">newshape</span>
    <span class="n">myslice</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">startind</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">endind</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">endind</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">myslice</span><span class="p">)]</span>


<div class="viewcode-block" id="fftconvolve"><a class="viewcode-back" href="../../../reference/forestci.calibration.html#forestci.calibration.fftconvolve">[docs]</a><span class="k">def</span> <span class="nf">fftconvolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convolve two N-dimensional arrays using FFT.</span>

<span class="sd">    Convolve `in1` and `in2` using the fast Fourier transform method, with</span>
<span class="sd">    the output size determined by the `mode` argument.</span>

<span class="sd">    This is generally much faster than `convolve` for large arrays (n &gt; ~500),</span>
<span class="sd">    but can be slower when only a few output values are needed, and can only</span>
<span class="sd">    output float arrays (int or object array inputs will be cast to float).</span>

<span class="sd">    As of v0.19, `convolve` automatically chooses this method or the direct</span>
<span class="sd">    method based on an estimation of which is faster.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">        If operating in &#39;valid&#39; mode, either `in1` or `in2` must be</span>
<span class="sd">        at least as large as the other in every dimension.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Autocorrelation of white noise is an impulse.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; sig = np.random.randn(1000)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = signal.fftconvolve(sig, sig[::-1], mode=&#39;full&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_mag) = plt.subplots(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;White noise&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.plot(np.arange(-len(sig)+1,len(sig)), autocorr)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_title(&#39;Autocorrelation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    Gaussian blur implemented using FFT convolution.  Notice the dark borders</span>
<span class="sd">    around the image, due to the zero-padding beyond its boundaries.</span>
<span class="sd">    The `convolve2d` function allows for other types of image boundaries,</span>
<span class="sd">    but is far slower.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import misc</span>
<span class="sd">    &gt;&gt;&gt; face = misc.face(gray=True)</span>
<span class="sd">    &gt;&gt;&gt; kernel = np.outer(signal.gaussian(70, 8), signal.gaussian(70, 8))</span>
<span class="sd">    &gt;&gt;&gt; blurred = signal.fftconvolve(face, kernel, mode=&#39;same&#39;)</span>

<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_kernel, ax_blurred) = plt.subplots(3, 1,</span>
<span class="sd">    ...                                                      figsize=(6, 15))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.imshow(face, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_kernel.imshow(kernel, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_kernel.set_title(&#39;Gaussian kernel&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_kernel.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_blurred.imshow(blurred, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_blurred.set_title(&#39;Blurred&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_blurred.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># scalar inputs</span>
        <span class="k">return</span> <span class="n">in1</span> <span class="o">*</span> <span class="n">in2</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;in1 and in2 should have the same dimensionality&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">in2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># empty arrays</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([])</span>

    <span class="n">s1</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">complex_result</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">in1</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">or</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">in2</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">))</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Check that input sizes are compatible with &#39;valid&#39; mode</span>
    <span class="k">if</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="c1"># Convolution is commutative; order doesn&#39;t have any effect on output</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">in1</span><span class="p">,</span> <span class="n">s1</span>

    <span class="c1"># Speed up FFT by padding to optimal size for FFTPACK</span>
    <span class="n">fshape</span> <span class="o">=</span> <span class="p">[</span><span class="n">fftpack</span><span class="o">.</span><span class="n">helper</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">]</span>
    <span class="n">fslice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sz</span><span class="p">))</span> <span class="k">for</span> <span class="n">sz</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">])</span>
    <span class="c1"># Pre-1.9 NumPy FFT routines are not threadsafe.  For older NumPys, make</span>
    <span class="c1"># sure we only call rfftn/irfftn from one thread at a time.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_result</span> <span class="ow">and</span> <span class="p">(</span><span class="n">_rfft_mt_safe</span> <span class="ow">or</span> <span class="n">_rfft_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="kc">False</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">fshape</span><span class="p">)</span>
            <span class="n">sp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">in2</span><span class="p">,</span> <span class="n">fshape</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">sp1</span> <span class="o">*</span> <span class="n">sp2</span><span class="p">,</span> <span class="n">fshape</span><span class="p">)[</span><span class="n">fslice</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_rfft_mt_safe</span><span class="p">:</span>
                <span class="n">_rfft_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If we&#39;re here, it&#39;s either because we need a complex result, or we</span>
        <span class="c1"># failed to acquire _rfft_lock (meaning rfftn isn&#39;t threadsafe and</span>
        <span class="c1"># is already in use by another thread).  In either case, use the</span>
        <span class="c1"># (threadsafe but slower) SciPy complex-FFT routines instead.</span>
        <span class="n">sp1</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">fshape</span><span class="p">)</span>
        <span class="n">sp2</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">in2</span><span class="p">,</span> <span class="n">fshape</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">sp1</span> <span class="o">*</span> <span class="n">sp2</span><span class="p">)[</span><span class="n">fslice</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_result</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;same&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_centered</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;valid&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_centered</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Acceptable mode flags are &#39;valid&#39;,&quot;</span>
                         <span class="s2">&quot; &#39;same&#39;, or &#39;full&#39;.&quot;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_numeric_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">kinds</span><span class="o">=</span><span class="s1">&#39;buifc&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if a list of arrays are all numeric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ndarrays : array or list of arrays</span>
<span class="sd">        arrays to check if numeric.</span>
<span class="sd">    numeric_kinds : string-like</span>
<span class="sd">        The dtypes of the arrays to be checked. If the dtype.kind of</span>
<span class="sd">        the ndarrays are not in this string the function returns False and</span>
<span class="sd">        otherwise returns True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arrays</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">kinds</span>
    <span class="k">for</span> <span class="n">array_</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">array_</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_prod</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Product of a list of numbers.</span>
<span class="sd">    Faster than np.prod for short lists like array shapes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
        <span class="n">product</span> <span class="o">*=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">product</span>


<span class="k">def</span> <span class="nf">_fftconv_faster</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if using `fftconvolve` or `_correlateND` is faster. The boolean value</span>
<span class="sd">    returned depends on the sizes and shapes of the input values.</span>

<span class="sd">    The big O ratios were found to hold across different machines, which makes</span>
<span class="sd">    sense as it&#39;s the ratio that matters (the effective speed of the computer</span>
<span class="sd">    is found in both big O constants). Regardless, this had been tuned on an</span>
<span class="sd">    early 2015 MacBook Pro with 8GB RAM and an Intel i5 processor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="n">big_O_constant</span> <span class="o">=</span> <span class="mf">10963.92823819</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">8899.1104874</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">big_O_constant</span> <span class="o">=</span> <span class="mf">7183.41306773</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">big_O_constant</span> <span class="o">=</span> <span class="mf">856.78174111</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">big_O_constant</span> <span class="o">=</span> <span class="mf">34519.21021589</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
        <span class="n">big_O_constant</span> <span class="o">=</span> <span class="mf">41954.28006344</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mf">66453.24316434</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mode is invalid&#39;</span><span class="p">)</span>

    <span class="c1"># see whether the Fourier transform convolution method or the direct</span>
    <span class="c1"># convolution method is faster (discussed in scikit-image PR #1792)</span>
    <span class="n">direct_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="n">_prod</span><span class="p">(</span><span class="n">out_shape</span><span class="p">))</span>
    <span class="n">fft_time</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">h</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span>
                                             <span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">big_O_constant</span> <span class="o">*</span> <span class="n">fft_time</span> <span class="o">&lt;</span> <span class="n">direct_time</span>


<span class="k">def</span> <span class="nf">_reverse_and_conj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse array `x` in all dimensions and perform the complex conjugate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reverse</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">reverse</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_np_conv_ok</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if numpy supports convolution of `volume` and `kernel` (i.e. both are</span>
<span class="sd">    1D ndarrays and of the appropriate shape).  Numpy&#39;s &#39;same&#39; mode uses the</span>
<span class="sd">    size of the larger input, while Scipy&#39;s uses the size of the first input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np_conv_ok</span> <span class="o">=</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">np_conv_ok</span> <span class="ow">and</span> <span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_timeit_fast</span><span class="p">(</span><span class="n">stmt</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="s2">&quot;pass&quot;</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the time the statement/function took, in seconds.</span>

<span class="sd">    Faster, less precise version of IPython&#39;s timeit. `stmt` can be a statement</span>
<span class="sd">    written as a string or a callable.</span>

<span class="sd">    Will do only 1 loop (like IPython&#39;s timeit) with no repetitions</span>
<span class="sd">    (unlike IPython) for very slow functions.  For fast functions, only does</span>
<span class="sd">    enough loops to take 5 ms, which seems to produce similar results (on</span>
<span class="sd">    Windows at least), and avoids doing an extraneous cycle that isn&#39;t</span>
<span class="sd">    measured.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">timer</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">Timer</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">setup</span><span class="p">)</span>

    <span class="c1"># determine number of calls per rep so total time for 1 rep &gt;= 5 ms</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="n">p</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>  <span class="c1"># seconds</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">5e-3</span> <span class="o">/</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># 5 ms for final test, 1/10th that for this one</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># second</span>
        <span class="c1"># If it&#39;s macroscopic, don&#39;t bother with repetitions</span>
        <span class="n">best</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">number</span> <span class="o">*=</span> <span class="mi">10</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">timer</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>
        <span class="n">best</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="n">sec</span> <span class="o">=</span> <span class="n">best</span> <span class="o">/</span> <span class="n">number</span>
    <span class="k">return</span> <span class="n">sec</span>


<span class="k">def</span> <span class="nf">choose_conv_method</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the fastest convolution/correlation method.</span>

<span class="sd">    This primarily exists to be called during the ``method=&#39;auto&#39;`` option in</span>
<span class="sd">    `convolve` and `correlate`, but can also be used when performing many</span>
<span class="sd">    convolutions of the same input shapes and dtypes, determining</span>
<span class="sd">    which method to use for all of them, either to avoid the overhead of the</span>
<span class="sd">    &#39;auto&#39; option or to use accurate real-world measurements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        The first argument passed into the convolution function.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        The second argument passed into the convolution function.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    measure : bool, optional</span>
<span class="sd">        If True, run and time the convolution of `in1` and `in2` with both</span>
<span class="sd">        methods and return the fastest. If False (default), predict the fastest</span>
<span class="sd">        method using precomputed values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    method : str</span>
<span class="sd">        A string indicating which convolution method is fastest, either</span>
<span class="sd">        &#39;direct&#39; or &#39;fft&#39;</span>
<span class="sd">    times : dict, optional</span>
<span class="sd">        A dictionary containing the times (in seconds) needed for each method.</span>
<span class="sd">        This value is only returned if ``measure=True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve</span>
<span class="sd">    correlate</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For large n, ``measure=False`` is accurate and can quickly determine the</span>
<span class="sd">    fastest method to perform the convolution.  However, this is not as</span>
<span class="sd">    accurate for small n (when any dimension in the input or output is small).</span>

<span class="sd">    In practice, we found that this function estimates the faster method up to</span>
<span class="sd">    a multiplicative factor of 5 (i.e., the estimated method is *at most* 5</span>
<span class="sd">    times slower than the fastest method). The estimation values were tuned on</span>
<span class="sd">    an early 2015 MacBook Pro with 8GB RAM but we found that the prediction</span>
<span class="sd">    held *fairly* accurately across different machines.</span>

<span class="sd">    If ``measure=True``, time the convolutions. Because this function uses</span>
<span class="sd">    `fftconvolve`, an error will be thrown if it does not support the inputs.</span>
<span class="sd">    There are cases when `fftconvolve` supports the inputs but this function</span>
<span class="sd">    returns `direct` (e.g., to protect against floating point integer</span>
<span class="sd">    precision).</span>

<span class="sd">    .. versionadded:: 0.19</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Estimate the fastest method for a given input:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.randn(1000)</span>
<span class="sd">    &gt;&gt;&gt; b = np.random.randn(1000000)</span>
<span class="sd">    &gt;&gt;&gt; method = signal.choose_conv_method(a, b, mode=&#39;same&#39;)</span>
<span class="sd">    &gt;&gt;&gt; method</span>
<span class="sd">    &#39;fft&#39;</span>

<span class="sd">    This can then be applied to other arrays of the same dtype and shape:</span>

<span class="sd">    &gt;&gt;&gt; c = np.random.randn(1000)</span>
<span class="sd">    &gt;&gt;&gt; d = np.random.randn(1000000)</span>
<span class="sd">    &gt;&gt;&gt; # `method` works with correlate and convolve</span>
<span class="sd">    &gt;&gt;&gt; corr1 = signal.correlate(a, b, mode=&#39;same&#39;, method=method)</span>
<span class="sd">    &gt;&gt;&gt; corr2 = signal.correlate(c, d, mode=&#39;same&#39;, method=method)</span>
<span class="sd">    &gt;&gt;&gt; conv1 = signal.convolve(a, b, mode=&#39;same&#39;, method=method)</span>
<span class="sd">    &gt;&gt;&gt; conv2 = signal.convolve(c, d, mode=&#39;same&#39;, method=method)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">measure</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fft&#39;</span><span class="p">,</span> <span class="s1">&#39;direct&#39;</span><span class="p">]:</span>
            <span class="n">times</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">_timeit_fast</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">convolve</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span>
                                         <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">))</span>

        <span class="n">chosen_method</span> <span class="o">=</span> <span class="s1">&#39;fft&#39;</span> <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="s1">&#39;fft&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="s1">&#39;direct&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;direct&#39;</span>
        <span class="k">return</span> <span class="n">chosen_method</span><span class="p">,</span> <span class="n">times</span>

    <span class="c1"># fftconvolve doesn&#39;t support complex256</span>
    <span class="n">fftconv_unsup</span> <span class="o">=</span> <span class="s2">&quot;complex256&quot;</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span> <span class="k">else</span> <span class="s2">&quot;complex192&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">fftconv_unsup</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">volume</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">fftconv_unsup</span> <span class="ow">or</span> <span class="n">kernel</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">fftconv_unsup</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>

    <span class="c1"># for integer input,</span>
    <span class="c1"># catch when more precision required than float provides (representing an</span>
    <span class="c1"># integer as float can lose precision in fftconvolve if larger than 2**52)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">_numeric_arrays</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">kinds</span><span class="o">=</span><span class="s1">&#39;ui&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">]]):</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">max_value</span> <span class="o">*=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_value</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nmant</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>

    <span class="k">if</span> <span class="n">_numeric_arrays</span><span class="p">([</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">],</span> <span class="n">kinds</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>

    <span class="k">if</span> <span class="n">_numeric_arrays</span><span class="p">([</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">_fftconv_faster</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;fft&#39;</span>

    <span class="k">return</span> <span class="s1">&#39;direct&#39;</span>


<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two N-dimensional arrays.</span>

<span class="sd">    Convolve `in1` and `in2`, with the output size determined by the</span>
<span class="sd">    `mode` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding. In &#39;valid&#39; mode, either `in1` or `in2`</span>
<span class="sd">           must be at least as large as the other in every dimension.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>
<span class="sd">    method : str {&#39;auto&#39;, &#39;direct&#39;, &#39;fft&#39;}, optional</span>
<span class="sd">        A string indicating which method to use to calculate the convolution.</span>

<span class="sd">        ``direct``</span>
<span class="sd">           The convolution is determined directly from sums, the definition of</span>
<span class="sd">           convolution.</span>
<span class="sd">        ``fft``</span>
<span class="sd">           The Fourier Transform is used to perform the convolution by calling</span>
<span class="sd">           `fftconvolve`.</span>
<span class="sd">        ``auto``</span>
<span class="sd">           Automatically chooses direct or Fourier method based on an estimate</span>
<span class="sd">           of which is faster (default).  See Notes for more detail.</span>

<span class="sd">           .. versionadded:: 0.19.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    convolve : array</span>
<span class="sd">        An N-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.polymul : performs polynomial multiplication (same operation, but</span>
<span class="sd">                    also accepts poly1d objects)</span>
<span class="sd">    choose_conv_method : chooses the fastest appropriate convolution method</span>
<span class="sd">    fftconvolve</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, `convolve` and `correlate` use ``method=&#39;auto&#39;``, which calls</span>
<span class="sd">    `choose_conv_method` to choose the fastest method using pre-computed</span>
<span class="sd">    values (`choose_conv_method` can also measure real-world timing with a</span>
<span class="sd">    keyword argument). Because `fftconvolve` relies on floating point numbers,</span>
<span class="sd">    there are certain constraints that may force `method=direct` (more detail</span>
<span class="sd">    in `choose_conv_method` docstring).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Smooth a square pulse using a Hann window:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; sig = np.repeat([0., 1., 0.], 100)</span>
<span class="sd">    &gt;&gt;&gt; win = signal.hann(50)</span>
<span class="sd">    &gt;&gt;&gt; filtered = signal.convolve(sig, win, mode=&#39;same&#39;) / sum(win)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_win, ax_filt) = plt.subplots(3, 1, sharex=True)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(sig)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original pulse&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ax_win.plot(win)</span>
<span class="sd">    &gt;&gt;&gt; ax_win.set_title(&#39;Filter impulse response&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_win.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ax_filt.plot(filtered)</span>
<span class="sd">    &gt;&gt;&gt; ax_filt.set_title(&#39;Filtered signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_filt.margins(0, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; fig.tight_layout()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">volume</span> <span class="o">*</span> <span class="n">kernel</span>

    <span class="k">if</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">volume</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="c1"># Convolution is commutative; order doesn&#39;t have any effect on output</span>
        <span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">volume</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">choose_conv_method</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;fft&#39;</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result_type</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">}:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>

    <span class="c1"># fastpath to faster numpy.convolve for 1d inputs when possible</span>
    <span class="k">if</span> <span class="n">_np_conv_ok</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">correlate</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">_reverse_and_conj</span><span class="p">(</span><span class="n">kernel</span><span class="p">),</span> <span class="n">mode</span><span class="p">,</span> <span class="s1">&#39;direct&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">order_filter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform an order filter on an N-dimensional array.</span>

<span class="sd">    Perform an order filter on the array in.  The domain argument acts as a</span>
<span class="sd">    mask centered over each pixel.  The non-zero elements of domain are</span>
<span class="sd">    used to select elements surrounding each input pixel which are placed</span>
<span class="sd">    in a list.   The list is sorted, and the output for that pixel is the</span>
<span class="sd">    element corresponding to rank in the sorted list.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        The N-dimensional input array.</span>
<span class="sd">    domain : array_like</span>
<span class="sd">        A mask array with the same number of dimensions as `a`.</span>
<span class="sd">        Each dimension should have an odd number of elements.</span>
<span class="sd">    rank : int</span>
<span class="sd">        A non-negative integer which selects the element from the</span>
<span class="sd">        sorted list (0 corresponds to the smallest element, 1 is the</span>
<span class="sd">        next smallest element, etc.).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The results of the order filter in an array with the same</span>
<span class="sd">        shape as `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(25).reshape(5, 5)</span>
<span class="sd">    &gt;&gt;&gt; domain = np.identity(3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0,  1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8,  9],</span>
<span class="sd">           [10, 11, 12, 13, 14],</span>
<span class="sd">           [15, 16, 17, 18, 19],</span>
<span class="sd">           [20, 21, 22, 23, 24]])</span>
<span class="sd">    &gt;&gt;&gt; signal.order_filter(x, domain, 0)</span>
<span class="sd">    array([[  0.,   0.,   0.,   0.,   0.],</span>
<span class="sd">           [  0.,   0.,   1.,   2.,   0.],</span>
<span class="sd">           [  0.,   5.,   6.,   7.,   0.],</span>
<span class="sd">           [  0.,  10.,  11.,  12.,   0.],</span>
<span class="sd">           [  0.,   0.,   0.,   0.,   0.]])</span>
<span class="sd">    &gt;&gt;&gt; signal.order_filter(x, domain, 2)</span>
<span class="sd">    array([[  6.,   7.,   8.,   9.,   4.],</span>
<span class="sd">           [ 11.,  12.,  13.,  14.,   9.],</span>
<span class="sd">           [ 16.,  17.,  18.,  19.,  14.],</span>
<span class="sd">           [ 21.,  22.,  23.,  24.,  19.],</span>
<span class="sd">           [ 20.,  21.,  22.,  23.,  24.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each dimension of domain argument &quot;</span>
                             <span class="s2">&quot; should have an odd number of elements.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_order_filterND</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">medfilt</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a median filter on an N-dimensional array.</span>

<span class="sd">    Apply a median filter to the input array using a local window-size</span>
<span class="sd">    given by `kernel_size`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    volume : array_like</span>
<span class="sd">        An N-dimensional input array.</span>
<span class="sd">    kernel_size : array_like, optional</span>
<span class="sd">        A scalar or an N-length list giving the size of the median filter</span>
<span class="sd">        window in each dimension.  Elements of `kernel_size` should be odd.</span>
<span class="sd">        If `kernel_size` is a scalar, then this scalar is used as the size in</span>
<span class="sd">        each dimension. Default size is 3 for each dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        An array the same size as input containing the median filtered</span>
<span class="sd">        result.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">volume</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">volume</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kernel_size</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each element of kernel_size should be odd.&quot;</span><span class="p">)</span>

    <span class="n">domain</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>

    <span class="n">numels</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">numels</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_order_filterND</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">wiener</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">mysize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a Wiener filter on an N-dimensional array.</span>

<span class="sd">    Apply a Wiener filter to the N-dimensional array `im`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im : ndarray</span>
<span class="sd">        An N-dimensional array.</span>
<span class="sd">    mysize : int or array_like, optional</span>
<span class="sd">        A scalar or an N-length list giving the size of the Wiener filter</span>
<span class="sd">        window in each dimension.  Elements of mysize should be odd.</span>
<span class="sd">        If mysize is a scalar, then this scalar is used as the size</span>
<span class="sd">        in each dimension.</span>
<span class="sd">    noise : float, optional</span>
<span class="sd">        The noise-power to use. If None, then noise is estimated as the</span>
<span class="sd">        average of the local variance of the input.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Wiener filtered result with the same shape as `im`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mysize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mysize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">mysize</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">mysize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mysize</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">mysize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">mysize</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">im</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="c1"># Estimate the local mean</span>
    <span class="n">lMean</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="n">mysize</span><span class="p">),</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="n">product</span><span class="p">(</span><span class="n">mysize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Estimate the local variance</span>
    <span class="n">lVar</span> <span class="o">=</span> <span class="p">(</span><span class="n">correlate</span><span class="p">(</span><span class="n">im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="n">mysize</span><span class="p">),</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span>
            <span class="n">product</span><span class="p">(</span><span class="n">mysize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">lMean</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Estimate the noise power if needed.</span>
    <span class="k">if</span> <span class="n">noise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">lVar</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">im</span> <span class="o">-</span> <span class="n">lMean</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">*=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">noise</span> <span class="o">/</span> <span class="n">lVar</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">+=</span> <span class="n">lMean</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">lVar</span> <span class="o">&lt;</span> <span class="n">noise</span><span class="p">,</span> <span class="n">lMean</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">convolve2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve two 2-dimensional arrays.</span>

<span class="sd">    Convolve `in1` and `in2` with output size determined by `mode`, and</span>
<span class="sd">    boundary conditions determined by `boundary` and `fillvalue`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">        If operating in &#39;valid&#39; mode, either `in1` or `in2` must be</span>
<span class="sd">        at least as large as the other in every dimension.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear convolution</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>

<span class="sd">    boundary : str {&#39;fill&#39;, &#39;wrap&#39;, &#39;symm&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">        ``fill``</span>
<span class="sd">           pad input arrays with fillvalue. (default)</span>
<span class="sd">        ``wrap``</span>
<span class="sd">           circular boundary conditions.</span>
<span class="sd">        ``symm``</span>
<span class="sd">           symmetrical boundary conditions.</span>

<span class="sd">    fillvalue : scalar, optional</span>
<span class="sd">        Value to fill pad input arrays with. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A 2-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        convolution of `in1` with `in2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute the gradient of an image by 2D convolution with a complex Scharr</span>
<span class="sd">    operator.  (Horizontal operator is real, vertical is imaginary.)  Use</span>
<span class="sd">    symmetric boundary condition to avoid creating edges at the image</span>
<span class="sd">    boundaries.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; from scipy import misc</span>
<span class="sd">    &gt;&gt;&gt; ascent = misc.ascent()</span>
<span class="sd">    &gt;&gt;&gt; scharr = np.array([[ -3-3j, 0-10j,  +3 -3j],</span>
<span class="sd">    ...                    [-10+0j, 0+ 0j, +10 +0j],</span>
<span class="sd">    ...                    [ -3+3j, 0+10j,  +3 +3j]]) # Gx + j*Gy</span>
<span class="sd">    &gt;&gt;&gt; grad = signal.convolve2d(ascent, scharr, boundary=&#39;symm&#39;, mode=&#39;same&#39;)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_mag, ax_ang) = plt.subplots(3, 1, figsize=(6, 15))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.imshow(ascent, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.imshow(np.absolute(grad), cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_title(&#39;Gradient magnitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_mag.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_ang.imshow(np.angle(grad), cmap=&#39;hsv&#39;) # hsv is cyclic, like angles</span>
<span class="sd">    &gt;&gt;&gt; ax_ang.set_title(&#39;Gradient orientation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_ang.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;convolve2d inputs must both be 2D arrays&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">_valfrommode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">bval</span> <span class="o">=</span> <span class="n">_bvalfromboundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_convolve2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bval</span><span class="p">,</span> <span class="n">fillvalue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">correlate2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlate two 2-dimensional arrays.</span>

<span class="sd">    Cross correlate `in1` and `in2` with output size determined by `mode`, and</span>
<span class="sd">    boundary conditions determined by `boundary` and `fillvalue`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    in1 : array_like</span>
<span class="sd">        First input.</span>
<span class="sd">    in2 : array_like</span>
<span class="sd">        Second input. Should have the same number of dimensions as `in1`.</span>
<span class="sd">        If operating in &#39;valid&#39; mode, either `in1` or `in2` must be</span>
<span class="sd">        at least as large as the other in every dimension.</span>
<span class="sd">    mode : str {&#39;full&#39;, &#39;valid&#39;, &#39;same&#39;}, optional</span>
<span class="sd">        A string indicating the size of the output:</span>

<span class="sd">        ``full``</span>
<span class="sd">           The output is the full discrete linear cross-correlation</span>
<span class="sd">           of the inputs. (Default)</span>
<span class="sd">        ``valid``</span>
<span class="sd">           The output consists only of those elements that do not</span>
<span class="sd">           rely on the zero-padding.</span>
<span class="sd">        ``same``</span>
<span class="sd">           The output is the same size as `in1`, centered</span>
<span class="sd">           with respect to the &#39;full&#39; output.</span>

<span class="sd">    boundary : str {&#39;fill&#39;, &#39;wrap&#39;, &#39;symm&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">        ``fill``</span>
<span class="sd">           pad input arrays with fillvalue. (default)</span>
<span class="sd">        ``wrap``</span>
<span class="sd">           circular boundary conditions.</span>
<span class="sd">        ``symm``</span>
<span class="sd">           symmetrical boundary conditions.</span>

<span class="sd">    fillvalue : scalar, optional</span>
<span class="sd">        Value to fill pad input arrays with. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    correlate2d : ndarray</span>
<span class="sd">        A 2-dimensional array containing a subset of the discrete linear</span>
<span class="sd">        cross-correlation of `in1` with `in2`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use 2D cross-correlation to find the location of a template in a noisy</span>
<span class="sd">    image:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; from scipy import misc</span>
<span class="sd">    &gt;&gt;&gt; face = misc.face(gray=True) - misc.face(gray=True).mean()</span>
<span class="sd">    &gt;&gt;&gt; template = np.copy(face[300:365, 670:750])  # right eye</span>
<span class="sd">    &gt;&gt;&gt; template -= template.mean()</span>
<span class="sd">    &gt;&gt;&gt; face = face + np.random.randn(*face.shape) * 50  # add noise</span>
<span class="sd">    &gt;&gt;&gt; corr = signal.correlate2d(face, template, boundary=&#39;symm&#39;, mode=&#39;same&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y, x = np.unravel_index(np.argmax(corr), corr.shape)  # find the match</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; fig, (ax_orig, ax_template, ax_corr) = plt.subplots(3, 1,</span>
<span class="sd">    ...                                                     figsize=(6, 15))</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.imshow(face, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_title(&#39;Original&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_template.imshow(template, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_template.set_title(&#39;Template&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_template.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.imshow(corr, cmap=&#39;gray&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_title(&#39;Cross-correlation&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax_corr.set_axis_off()</span>
<span class="sd">    &gt;&gt;&gt; ax_orig.plot(x, y, &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fig.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">in1</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in1</span><span class="p">)</span>
    <span class="n">in2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">in2</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">in1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">in2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;correlate2d inputs must both be 2D arrays&#39;</span><span class="p">)</span>

    <span class="n">swapped_inputs</span> <span class="o">=</span> <span class="n">_inputs_swap_needed</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
        <span class="n">in1</span><span class="p">,</span> <span class="n">in2</span> <span class="o">=</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in1</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">_valfrommode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">bval</span> <span class="o">=</span> <span class="n">_bvalfromboundary</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_convolve2d</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">bval</span><span class="p">,</span> <span class="n">fillvalue</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">swapped_inputs</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">medfilt2d</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Median filter a 2-dimensional array.</span>

<span class="sd">    Apply a median filter to the `input` array using a local window-size</span>
<span class="sd">    given by `kernel_size` (must be odd).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : array_like</span>
<span class="sd">        A 2-dimensional input array.</span>
<span class="sd">    kernel_size : array_like, optional</span>
<span class="sd">        A scalar or a list of length 2, giving the size of the</span>
<span class="sd">        median filter window in each dimension.  Elements of</span>
<span class="sd">        `kernel_size` should be odd.  If `kernel_size` is a scalar,</span>
<span class="sd">        then this scalar is used as the size in each dimension.</span>
<span class="sd">        Default is a kernel of size (3, 3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        An array the same size as input containing the median filtered</span>
<span class="sd">        result.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel_size</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">kernel_size</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Each element of kernel_size should be odd.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_medfilt2d</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter data along one-dimension with an IIR or FIR filter.</span>

<span class="sd">    Filter a data sequence, `x`, using a digital filter.  This works for many</span>
<span class="sd">    fundamental data types (including Object type).  The filter is a direct</span>
<span class="sd">    form II transposed implementation of the standard difference equation</span>
<span class="sd">    (see Notes).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        The numerator coefficient vector in a 1-D sequence.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The denominator coefficient vector in a 1-D sequence.  If ``a[0]``</span>
<span class="sd">        is not 1, then both `a` and `b` are normalized by ``a[0]``.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        An N-dimensional input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of the input data array along which to apply the</span>
<span class="sd">        linear filter. The filter is applied to each subarray along</span>
<span class="sd">        this axis.  Default is -1.</span>
<span class="sd">    zi : array_like, optional</span>
<span class="sd">        Initial conditions for the filter delays.  It is a vector</span>
<span class="sd">        (or array of vectors for an N-dimensional input) of length</span>
<span class="sd">        ``max(len(a), len(b)) - 1``.  If `zi` is None or is not given then</span>
<span class="sd">        initial rest is assumed.  See `lfiltic` for more information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : array</span>
<span class="sd">        The output of the digital filter.</span>
<span class="sd">    zf : array, optional</span>
<span class="sd">        If `zi` is None, this is not returned, otherwise, `zf` holds the</span>
<span class="sd">        final filter delay values.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lfiltic : Construct initial conditions for `lfilter`.</span>
<span class="sd">    lfilter_zi : Compute initial state (steady state of step response) for</span>
<span class="sd">                 `lfilter`.</span>
<span class="sd">    filtfilt : A forward-backward filter, to obtain a filter with linear phase.</span>
<span class="sd">    savgol_filter : A Savitzky-Golay filter.</span>
<span class="sd">    sosfilt: Filter data using cascaded second-order sections.</span>
<span class="sd">    sosfiltfilt: A forward-backward filter using second-order sections.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The filter function is implemented as a direct II transposed structure.</span>
<span class="sd">    This means that the filter implements::</span>

<span class="sd">       a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[M]*x[n-M]</span>
<span class="sd">                             - a[1]*y[n-1] - ... - a[N]*y[n-N]</span>

<span class="sd">    where `M` is the degree of the numerator, `N` is the degree of the</span>
<span class="sd">    denominator, and `n` is the sample number.  It is implemented using</span>
<span class="sd">    the following difference equations (assuming M = N)::</span>

<span class="sd">         a[0]*y[n] = b[0] * x[n]               + d[0][n-1]</span>
<span class="sd">           d[0][n] = b[1] * x[n] - a[1] * y[n] + d[1][n-1]</span>
<span class="sd">           d[1][n] = b[2] * x[n] - a[2] * y[n] + d[2][n-1]</span>
<span class="sd">         ...</span>
<span class="sd">         d[N-2][n] = b[N-1]*x[n] - a[N-1]*y[n] + d[N-1][n-1]</span>
<span class="sd">         d[N-1][n] = b[N] * x[n] - a[N] * y[n]</span>

<span class="sd">    where `d` are the state variables.</span>

<span class="sd">    The rational transfer function describing this filter in the</span>
<span class="sd">    z-transform domain is::</span>

<span class="sd">                             -1              -M</span>
<span class="sd">                 b[0] + b[1]z  + ... + b[M] z</span>
<span class="sd">         Y(z) = -------------------------------- X(z)</span>
<span class="sd">                             -1              -N</span>
<span class="sd">                 a[0] + a[1]z  + ... + a[N] z</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Generate a noisy signal to be filtered:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(-1, 1, 201)</span>
<span class="sd">    &gt;&gt;&gt; x = (np.sin(2*np.pi*0.75*t*(1-t) + 2.1) +</span>
<span class="sd">    ...      0.1*np.sin(2*np.pi*1.25*t + 1) +</span>
<span class="sd">    ...      0.18*np.cos(2*np.pi*3.85*t))</span>
<span class="sd">    &gt;&gt;&gt; xn = x + np.random.randn(len(t)) * 0.08</span>

<span class="sd">    Create an order 3 lowpass butterworth filter:</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(3, 0.05)</span>

<span class="sd">    Apply the filter to xn.  Use lfilter_zi to choose the initial condition of</span>
<span class="sd">    the filter:</span>

<span class="sd">    &gt;&gt;&gt; zi = signal.lfilter_zi(b, a)</span>
<span class="sd">    &gt;&gt;&gt; z, _ = signal.lfilter(b, a, xn, zi=zi*xn[0])</span>

<span class="sd">    Apply the filter again, to have a result filtered at an order the same as</span>
<span class="sd">    filtfilt:</span>

<span class="sd">    &gt;&gt;&gt; z2, _ = signal.lfilter(b, a, z, zi=zi*z[0])</span>

<span class="sd">    Use filtfilt to apply the filter:</span>

<span class="sd">    &gt;&gt;&gt; y = signal.filtfilt(b, a, xn)</span>

<span class="sd">    Plot the original signal and the various filtered versions:</span>

<span class="sd">    &gt;&gt;&gt; plt.figure</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, xn, &#39;b&#39;, alpha=0.75)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, z, &#39;r--&#39;, t, z2, &#39;r&#39;, t, y, &#39;k&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend((&#39;noisy signal&#39;, &#39;lfilter, once&#39;, &#39;lfilter, twice&#39;,</span>
<span class="sd">    ...             &#39;filtfilt&#39;), loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># This path only supports types fdgFDGO to mirror _linear_filter below.</span>
        <span class="c1"># Any of b, a, x, or zi can set the dtype, but there is no default</span>
        <span class="c1"># casting of other types; instead a NotImplementedError is raised.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object of too small depth for desired array&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># _linear_filter does not broadcast zi, but does do expansion of</span>
            <span class="c1"># singleton dims.</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;object of too small depth for desired array&#39;</span><span class="p">)</span>
            <span class="n">expected_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">expected_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">expected_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">expected_shape</span><span class="p">)</span>
            <span class="c1"># check the trivial case where zi is the right shape first</span>
            <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
                <span class="n">strides</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">axis</span> <span class="o">+=</span> <span class="n">zi</span><span class="o">.</span><span class="n">ndim</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected_shape</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">strides</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected shape for zi: expected &#39;</span>
                                         <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, found </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="n">expected_shape</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">expected_shape</span><span class="p">,</span>
                                                     <span class="n">strides</span><span class="p">)</span>
            <span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;fdgFDGO&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;input type &#39;</span><span class="si">%s</span><span class="s2">&#39; not supported&quot;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">/=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">out_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">out_full</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
            <span class="n">out_full</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+=</span> <span class="n">zi</span>

        <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">out_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out_full</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">out_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">zf</span> <span class="o">=</span> <span class="n">out_full</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">zf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_linear_filter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigtools</span><span class="o">.</span><span class="n">_linear_filter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">lfiltic</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct initial conditions for lfilter given input and output vectors.</span>

<span class="sd">    Given a linear filter (b, a) and initial conditions on the output `y`</span>
<span class="sd">    and the input `x`, return the initial conditions on the state vector zi</span>
<span class="sd">    which is used by `lfilter` to generate the output given the input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Linear filter term.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Linear filter term.</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Initial conditions.</span>

<span class="sd">        If ``N = len(a) - 1``, then ``y = {y[-1], y[-2], ..., y[-N]}``.</span>

<span class="sd">        If `y` is too short, it is padded with zeros.</span>
<span class="sd">    x : array_like, optional</span>
<span class="sd">        Initial conditions.</span>

<span class="sd">        If ``M = len(b) - 1``, then ``x = {x[-1], x[-2], ..., x[-M]}``.</span>

<span class="sd">        If `x` is not given, its initial conditions are assumed zero.</span>

<span class="sd">        If `x` is too short, it is padded with zeros.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zi : ndarray</span>
<span class="sd">        The state vector ``zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}``,</span>
<span class="sd">        where ``K = max(M, N)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lfilter, lfilter_zi</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;bui&#39;</span><span class="p">:</span>
        <span class="c1"># ensure calculations are floating point</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">L</span><span class="p">)]</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">r_</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">L</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[:</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[:</span><span class="n">N</span> <span class="o">-</span> <span class="n">m</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">zi</span>


<span class="k">def</span> <span class="nf">deconvolve</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">divisor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deconvolves ``divisor`` out of ``signal`` using inverse filtering.</span>

<span class="sd">    Returns the quotient and remainder such that</span>
<span class="sd">    ``signal = convolve(divisor, quotient) + remainder``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : array_like</span>
<span class="sd">        Signal data, typically a recorded signal</span>
<span class="sd">    divisor : array_like</span>
<span class="sd">        Divisor data, typically an impulse response or filter that was</span>
<span class="sd">        applied to the original signal</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quotient : ndarray</span>
<span class="sd">        Quotient, typically the recovered original signal</span>
<span class="sd">    remainder : ndarray</span>
<span class="sd">        Remainder</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Deconvolve a signal that&#39;s been filtered:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; original = [0, 1, 0, 0, 1, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; impulse_response = [2, 1]</span>
<span class="sd">    &gt;&gt;&gt; recorded = signal.convolve(impulse_response, original)</span>
<span class="sd">    &gt;&gt;&gt; recorded</span>
<span class="sd">    array([0, 2, 1, 0, 2, 3, 1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; recovered, remainder = signal.deconvolve(recorded, impulse_response)</span>
<span class="sd">    &gt;&gt;&gt; recovered</span>
<span class="sd">    array([ 0.,  1.,  0.,  0.,  1.,  1.,  0.,  0.])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.polydiv : performs polynomial division (same operation, but</span>
<span class="sd">                    also accepts poly1d objects)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">divisor</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">D</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">D</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">quot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">num</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">quot</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="nb">input</span><span class="p">)</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="n">convolve</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">quot</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span>


<span class="k">def</span> <span class="nf">hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the analytic signal, using the Hilbert transform.</span>

<span class="sd">    The transformation is done along the last axis by default.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Signal data.  Must be real.</span>
<span class="sd">    N : int, optional</span>
<span class="sd">        Number of Fourier components.  Default: ``x.shape[axis]``</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to do the transformation.  Default: -1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xa : ndarray</span>
<span class="sd">        Analytic signal of `x`, of each 1-D array along `axis`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.fftpack.hilbert : Return Hilbert transform of a periodic sequence x.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The analytic signal ``x_a(t)`` of signal ``x(t)`` is:</span>

<span class="sd">    .. math:: x_a = F^{-1}(F(x) 2U) = x + i y</span>

<span class="sd">    where `F` is the Fourier transform, `U` the unit step function,</span>
<span class="sd">    and `y` the Hilbert transform of `x`. [1]_</span>

<span class="sd">    In other words, the negative half of the frequency spectrum is zeroed</span>
<span class="sd">    out, turning the real-valued signal into a complex signal.  The Hilbert</span>
<span class="sd">    transformed signal can be obtained from ``np.imag(hilbert(x))``, and the</span>
<span class="sd">    original signal from ``np.real(hilbert(x))``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>
<span class="sd">    In this example we use the Hilbert transform to determine the amplitude</span>
<span class="sd">    envelope and instantaneous frequency of an amplitude-modulated signal.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import hilbert, chirp</span>

<span class="sd">    &gt;&gt;&gt; duration = 1.0</span>
<span class="sd">    &gt;&gt;&gt; fs = 400.0</span>
<span class="sd">    &gt;&gt;&gt; samples = int(fs*duration)</span>
<span class="sd">    &gt;&gt;&gt; t = np.arange(samples) / fs</span>

<span class="sd">    We create a chirp of which the frequency increases from 20 Hz to 100 Hz and</span>
<span class="sd">    apply an amplitude modulation.</span>

<span class="sd">    &gt;&gt;&gt; signal = chirp(t, 20.0, t[-1], 100.0)</span>
<span class="sd">    &gt;&gt;&gt; signal *= (1.0 + 0.5 * np.sin(2.0*np.pi*3.0*t) )</span>

<span class="sd">    The amplitude envelope is given by magnitude of the analytic signal. The</span>
<span class="sd">    instantaneous frequency can be obtained by differentiating the</span>
<span class="sd">    instantaneous phase in respect to time. The instantaneous phase corresponds</span>
<span class="sd">    to the phase angle of the analytic signal.</span>

<span class="sd">    &gt;&gt;&gt; analytic_signal = hilbert(signal)</span>
<span class="sd">    &gt;&gt;&gt; amplitude_envelope = np.abs(analytic_signal)</span>
<span class="sd">    &gt;&gt;&gt; instantaneous_phase = np.unwrap(np.angle(analytic_signal))</span>
<span class="sd">    &gt;&gt;&gt; instantaneous_frequency = (np.diff(instantaneous_phase) /</span>
<span class="sd">    ...                            (2.0*np.pi) * fs)</span>

<span class="sd">    &gt;&gt;&gt; fig = plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; ax0 = fig.add_subplot(211)</span>
<span class="sd">    &gt;&gt;&gt; ax0.plot(t, signal, label=&#39;signal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax0.plot(t, amplitude_envelope, label=&#39;envelope&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ax0.set_xlabel(&quot;time in seconds&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax0.legend()</span>
<span class="sd">    &gt;&gt;&gt; ax1 = fig.add_subplot(212)</span>
<span class="sd">    &gt;&gt;&gt; ax1.plot(t[1:], instantaneous_frequency)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_xlabel(&quot;time in seconds&quot;)</span>
<span class="sd">    &gt;&gt;&gt; ax1.set_ylim(0.0, 120.0)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Analytic signal&quot;.</span>
<span class="sd">           http://en.wikipedia.org/wiki/Analytic_signal</span>
<span class="sd">    .. [2] Leon Cohen, &quot;Time-Frequency Analysis&quot;, 1995. Chapter 2.</span>
<span class="sd">    .. [3] Alan V. Oppenheim, Ronald W. Schafer. Discrete-Time Signal</span>
<span class="sd">           Processing, Third Edition, 2009. Chapter 12.</span>
<span class="sd">           ISBN 13: 978-1292-02572-8</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be real.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be positive.&quot;</span><span class="p">)</span>

    <span class="n">Xf</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Xf</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">hilbert2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the &#39;2-D&#39; analytic signal of `x`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        2-D signal data.</span>
<span class="sd">    N : int or tuple of two ints, optional</span>
<span class="sd">        Number of Fourier components. Default is ``x.shape``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xa : ndarray</span>
<span class="sd">        Analytic signal of `x` taken along axes (0,1).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia, &quot;Analytic signal&quot;,</span>
<span class="sd">        http://en.wikipedia.org/wiki/Analytic_signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 2-D.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be real.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be positive.&quot;</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When given as a tuple, N must hold exactly &quot;</span>
                         <span class="s2">&quot;two positive integers&quot;</span><span class="p">)</span>

    <span class="n">Xf</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">h1</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="n">h2</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;h</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">N1</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">N1</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">N1</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N1</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="n">N1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">exec</span><span class="p">(</span><span class="s2">&quot;h</span><span class="si">%d</span><span class="s2"> = h&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">locals</span><span class="p">())</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">h1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">Xf</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span> <span class="nf">cmplx_sort</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort roots based on magnitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        The roots to sort, as a 1-D array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p_sorted : ndarray</span>
<span class="sd">        Sorted roots.</span>
<span class="sd">    indx : ndarray</span>
<span class="sd">        Array of indices needed to sort the input `p`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">indx</span>


<span class="k">def</span> <span class="nf">unique_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;min&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine unique roots and their multiplicities from a list of roots.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        The list of roots.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal. Default is 1e-3.</span>
<span class="sd">    rtype : {&#39;max&#39;, &#39;min, &#39;avg&#39;}, optional</span>
<span class="sd">        How to determine the returned root if multiple roots are within</span>
<span class="sd">        `tol` of each other.</span>

<span class="sd">          - &#39;max&#39;: pick the maximum of those roots.</span>
<span class="sd">          - &#39;min&#39;: pick the minimum of those roots.</span>
<span class="sd">          - &#39;avg&#39;: take the average of those roots.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    pout : ndarray</span>
<span class="sd">        The list of unique roots, sorted from low to high.</span>
<span class="sd">    mult : ndarray</span>
<span class="sd">        The multiplicity of each root.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This utility function is not specific to roots but can be used for any</span>
<span class="sd">    sequence of values for which uniqueness and multiplicity has to be</span>
<span class="sd">    determined. For a more general routine, see `numpy.unique`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; vals = [0, 1.3, 1.31, 2.8, 1.25, 2.2, 10.3]</span>
<span class="sd">    &gt;&gt;&gt; uniq, mult = signal.unique_roots(vals, tol=2e-2, rtype=&#39;avg&#39;)</span>

<span class="sd">    Check which roots have multiplicity larger than 1:</span>

<span class="sd">    &gt;&gt;&gt; uniq[mult &gt; 1]</span>
<span class="sd">    array([ 1.305])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">]:</span>
        <span class="n">comproot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span>
    <span class="k">elif</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum&#39;</span><span class="p">]:</span>
        <span class="n">comproot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span>
    <span class="k">elif</span> <span class="n">rtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;avg&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
        <span class="n">comproot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`rtype` must be one of &quot;</span>
                         <span class="s2">&quot;{&#39;max&#39;, &#39;maximum&#39;, &#39;min&#39;, &#39;minimum&#39;, &#39;avg&#39;, &#39;mean&#39;}&quot;</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">pout</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mult</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">curp</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">tol</span>
    <span class="n">sameroots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tr</span> <span class="o">-</span> <span class="n">curp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">sameroots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="n">curp</span> <span class="o">=</span> <span class="n">comproot</span><span class="p">(</span><span class="n">sameroots</span><span class="p">)</span>
            <span class="n">pout</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">curp</span>
            <span class="n">mult</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pout</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="n">curp</span> <span class="o">=</span> <span class="n">tr</span>
            <span class="n">sameroots</span> <span class="o">=</span> <span class="p">[</span><span class="n">tr</span><span class="p">]</span>
            <span class="n">indx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">mult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">pout</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">invres</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute b(s) and a(s) from partial fraction expansion.</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]</span>
<span class="sd">      H(s) = ------ = ------------------------------------------</span>
<span class="sd">              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</span>

<span class="sd">    then the partial-fraction expansion H(s) is defined as::</span>

<span class="sd">               r[0]       r[1]             r[-1]</span>
<span class="sd">           = -------- + -------- + ... + --------- + k(s)</span>
<span class="sd">             (s-p[0])   (s-p[1])         (s-p[-1])</span>

<span class="sd">    If there are any repeated roots (closer together than `tol`), then H(s)</span>
<span class="sd">    has terms like::</span>

<span class="sd">          r[i]      r[i+1]              r[i+n-1]</span>
<span class="sd">        -------- + ----------- + ... + -----------</span>
<span class="sd">        (s-p[i])  (s-p[i])**2          (s-p[i])**n</span>

<span class="sd">    This function is used for polynomials in positive powers of s or z,</span>
<span class="sd">    such as analog filters or digital filters in controls engineering.  For</span>
<span class="sd">    negative powers of z (typical for digital filters in DSP), use `invresz`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like</span>
<span class="sd">        Residues.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles.</span>
<span class="sd">    k : array_like</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal. Default is 1e-3.</span>
<span class="sd">    rtype : {&#39;max&#39;, &#39;min, &#39;avg&#39;}, optional</span>
<span class="sd">        How to determine the returned root if multiple roots are within</span>
<span class="sd">        `tol` of each other.</span>

<span class="sd">          - &#39;max&#39;: pick the maximum of those roots.</span>
<span class="sd">          - &#39;min&#39;: pick the minimum of those roots.</span>
<span class="sd">          - &#39;avg&#39;: take the average of those roots.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    residue, invresz, unique_roots</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">k</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">pout</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mult</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[:]</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mult</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">polyadd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">*</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">t2</span><span class="p">)))</span>
            <span class="n">indx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">real_if_close</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-14</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">residue</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute partial-fraction expansion of b(s) / a(s).</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">              b(s)     b[0] s**(M) + b[1] s**(M-1) + ... + b[M]</span>
<span class="sd">      H(s) = ------ = ------------------------------------------</span>
<span class="sd">              a(s)     a[0] s**(N) + a[1] s**(N-1) + ... + a[N]</span>

<span class="sd">    then the partial-fraction expansion H(s) is defined as::</span>

<span class="sd">               r[0]       r[1]             r[-1]</span>
<span class="sd">           = -------- + -------- + ... + --------- + k(s)</span>
<span class="sd">             (s-p[0])   (s-p[1])         (s-p[-1])</span>

<span class="sd">    If there are any repeated roots (closer together than `tol`), then H(s)</span>
<span class="sd">    has terms like::</span>

<span class="sd">          r[i]      r[i+1]              r[i+n-1]</span>
<span class="sd">        -------- + ----------- + ... + -----------</span>
<span class="sd">        (s-p[i])  (s-p[i])**2          (s-p[i])**n</span>

<span class="sd">    This function is used for polynomials in positive powers of s or z,</span>
<span class="sd">    such as analog filters or digital filters in controls engineering.  For</span>
<span class="sd">    negative powers of z (typical for digital filters in DSP), use `residuez`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        Residues.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles.</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    invres, residuez, numpy.poly, unique_roots</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">rscale</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">polydiv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="mf">0.0</span>
    <span class="n">pout</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># Compute the residue from the general formula</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">bn</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">pn</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
        <span class="n">an</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">pn</span><span class="p">))</span>
        <span class="c1"># bn(s) / an(s) is (s-po[n])**Nn * b(s) / a(s) where Nn is</span>
        <span class="c1"># multiplicity of pole at po[n]</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">mult</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sig</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="c1"># compute next derivative of bn(s) / an(s)</span>
                <span class="n">term1</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">polyder</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">an</span><span class="p">)</span>
                <span class="n">term2</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">polyder</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">bn</span> <span class="o">=</span> <span class="n">polysub</span><span class="p">(</span><span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">)</span>
                <span class="n">an</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">an</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">indx</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">polyval</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">/</span> <span class="n">polyval</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">/</span>
                               <span class="n">factorial</span><span class="p">(</span><span class="n">sig</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">indx</span> <span class="o">+=</span> <span class="n">sig</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">/</span> <span class="n">rscale</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">residuez</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute partial-fraction expansion of b(z) / a(z).</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)</span>
<span class="sd">        H(z) = ------ = ------------------------------------------</span>
<span class="sd">                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</span>

<span class="sd">    then the partial-fraction expansion H(z) is defined as::</span>

<span class="sd">                 r[0]                   r[-1]</span>
<span class="sd">         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...</span>
<span class="sd">           (1-p[0]z**(-1))         (1-p[-1]z**(-1))</span>

<span class="sd">    If there are any repeated roots (closer than `tol`), then the partial</span>
<span class="sd">    fraction expansion has terms like::</span>

<span class="sd">             r[i]              r[i+1]                    r[i+n-1]</span>
<span class="sd">        -------------- + ------------------ + ... + ------------------</span>
<span class="sd">        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n</span>

<span class="sd">    This function is used for polynomials in negative powers of z,</span>
<span class="sd">    such as digital filters in DSP.  For positive powers, use `residue`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : ndarray</span>
<span class="sd">        Residues.</span>
<span class="sd">    p : ndarray</span>
<span class="sd">        Poles.</span>
<span class="sd">    k : ndarray</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    invresz, residue, unique_roots</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">brev</span><span class="p">,</span> <span class="n">arev</span> <span class="o">=</span> <span class="n">b</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">krev</span><span class="p">,</span> <span class="n">brev</span> <span class="o">=</span> <span class="n">polydiv</span><span class="p">(</span><span class="n">brev</span><span class="p">,</span> <span class="n">arev</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">krev</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">krev</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">brev</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">roots</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="mf">0.0</span>
    <span class="n">pout</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># Compute the residue from the general formula (for discrete-time)</span>
    <span class="c1">#  the polynomial is in z**(-1) and the multiplication is by terms</span>
    <span class="c1">#  like this (1-p[i] z**(-1))**mult[i].  After differentiation,</span>
    <span class="c1">#  we must divide by (-p[i])**(m-k) as well as (m-k)!</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">bn</span> <span class="o">=</span> <span class="n">brev</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">pn</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
        <span class="n">an</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">pn</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># bn(z) / an(z) is (1-po[n] z**(-1))**Nn * b(z) / a(z) where Nn is</span>
        <span class="c1"># multiplicity of pole at po[n] and b(z) and a(z) are polynomials.</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">mult</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sig</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="c1"># compute next derivative of bn(s) / an(s)</span>
                <span class="n">term1</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">polyder</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">an</span><span class="p">)</span>
                <span class="n">term2</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">polyder</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">bn</span> <span class="o">=</span> <span class="n">polysub</span><span class="p">(</span><span class="n">term1</span><span class="p">,</span> <span class="n">term2</span><span class="p">)</span>
                <span class="n">an</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">an</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">indx</span> <span class="o">+</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">polyval</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">/</span>
                               <span class="n">polyval</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">/</span>
                               <span class="n">factorial</span><span class="p">(</span><span class="n">sig</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="n">pout</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="n">sig</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">indx</span> <span class="o">+=</span> <span class="n">sig</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">/</span> <span class="n">gain</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">invresz</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute b(z) and a(z) from partial fraction expansion.</span>

<span class="sd">    If `M` is the degree of numerator `b` and `N` the degree of denominator</span>
<span class="sd">    `a`::</span>

<span class="sd">                b(z)     b[0] + b[1] z**(-1) + ... + b[M] z**(-M)</span>
<span class="sd">        H(z) = ------ = ------------------------------------------</span>
<span class="sd">                a(z)     a[0] + a[1] z**(-1) + ... + a[N] z**(-N)</span>

<span class="sd">    then the partial-fraction expansion H(z) is defined as::</span>

<span class="sd">                 r[0]                   r[-1]</span>
<span class="sd">         = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...</span>
<span class="sd">           (1-p[0]z**(-1))         (1-p[-1]z**(-1))</span>

<span class="sd">    If there are any repeated roots (closer than `tol`), then the partial</span>
<span class="sd">    fraction expansion has terms like::</span>

<span class="sd">             r[i]              r[i+1]                    r[i+n-1]</span>
<span class="sd">        -------------- + ------------------ + ... + ------------------</span>
<span class="sd">        (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n</span>

<span class="sd">    This function is used for polynomials in negative powers of z,</span>
<span class="sd">    such as digital filters in DSP.  For positive powers, use `invres`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : array_like</span>
<span class="sd">        Residues.</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Poles.</span>
<span class="sd">    k : array_like</span>
<span class="sd">        Coefficients of the direct polynomial term.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        The tolerance for two roots to be considered equal. Default is 1e-3.</span>
<span class="sd">    rtype : {&#39;max&#39;, &#39;min, &#39;avg&#39;}, optional</span>
<span class="sd">        How to determine the returned root if multiple roots are within</span>
<span class="sd">        `tol` of each other.</span>

<span class="sd">          - &#39;max&#39;: pick the maximum of those roots.</span>
<span class="sd">          - &#39;min&#39;: pick the minimum of those roots.</span>
<span class="sd">          - &#39;avg&#39;: take the average of those roots.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        Numerator polynomial coefficients.</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        Denominator polynomial coefficients.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    residuez, unique_roots, invres</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="n">cmplx_sort</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">pout</span><span class="p">,</span> <span class="n">mult</span> <span class="o">=</span> <span class="n">unique_roots</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">rtype</span><span class="o">=</span><span class="n">rtype</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">polymul</span><span class="p">(</span><span class="n">extra</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">brev</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Construct polynomial which does not include any of this root</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pout</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">*</span> <span class="n">mult</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mult</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[:]</span>
            <span class="n">t2</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pout</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mult</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">brev</span> <span class="o">=</span> <span class="n">polyadd</span><span class="p">(</span><span class="n">brev</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">*</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">t2</span><span class="p">)))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">indx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">real_if_close</span><span class="p">(</span><span class="n">brev</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample `x` to `num` samples using Fourier method along the given axis.</span>

<span class="sd">    The resampled signal starts at the same value as `x` but is sampled</span>
<span class="sd">    with a spacing of ``len(x) / num * (spacing of x)``.  Because a</span>
<span class="sd">    Fourier method is used, the signal is assumed to be periodic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The data to be resampled.</span>
<span class="sd">    num : int</span>
<span class="sd">        The number of samples in the resampled signal.</span>
<span class="sd">    t : array_like, optional</span>
<span class="sd">        If `t` is given, it is assumed to be the sample positions</span>
<span class="sd">        associated with the signal data in `x`.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` that is resampled.  Default is 0.</span>
<span class="sd">    window : array_like, callable, string, float, or tuple, optional</span>
<span class="sd">        Specifies the window applied to the signal in the Fourier</span>
<span class="sd">        domain.  See below for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    resampled_x or (resampled_x, resampled_t)</span>
<span class="sd">        Either the resampled array, or, if `t` was given, a tuple</span>
<span class="sd">        containing the resampled array and the corresponding resampled</span>
<span class="sd">        positions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    decimate : Downsample the signal after applying an FIR or IIR filter.</span>
<span class="sd">    resample_poly : Resample using polyphase filtering and an FIR filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The argument `window` controls a Fourier-domain window that tapers</span>
<span class="sd">    the Fourier spectrum before zero-padding to alleviate ringing in</span>
<span class="sd">    the resampled values for sampled signals you didn&#39;t intend to be</span>
<span class="sd">    interpreted as band-limited.</span>

<span class="sd">    If `window` is a function, then it is called with a vector of inputs</span>
<span class="sd">    indicating the frequency bins (i.e. fftfreq(x.shape[axis]) ).</span>

<span class="sd">    If `window` is an array of the same length as `x.shape[axis]` it is</span>
<span class="sd">    assumed to be the window to be applied directly in the Fourier</span>
<span class="sd">    domain (with dc and low-frequency first).</span>

<span class="sd">    For any other type of `window`, the function `scipy.signal.get_window`</span>
<span class="sd">    is called to generate the window.</span>

<span class="sd">    The first sample of the returned vector is the same as the first</span>
<span class="sd">    sample of the input vector.  The spacing between samples is changed</span>
<span class="sd">    from ``dx`` to ``dx * len(x) / num``.</span>

<span class="sd">    If `t` is not None, then it represents the old sample positions,</span>
<span class="sd">    and the new sample positions will be returned as well as the new</span>
<span class="sd">    samples.</span>

<span class="sd">    As noted, `resample` uses FFT transformations, which can be very</span>
<span class="sd">    slow if the number of input or output samples is large and prime;</span>
<span class="sd">    see `scipy.fftpack.fft`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Note that the end of the resampled data rises to meet the first</span>
<span class="sd">    sample of the next cycle:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = np.cos(-x**2/6.0)</span>
<span class="sd">    &gt;&gt;&gt; f = signal.resample(y, 100)</span>
<span class="sd">    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;go-&#39;, xnew, f, &#39;.-&#39;, 10, y[0], &#39;ro&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend([&#39;data&#39;, &#39;resampled&#39;], loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">fftpack</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;window must have the same length as data&#39;</span><span class="p">)</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">window</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="n">W</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">newshape</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">W</span>
        <span class="n">W</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,)</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">Nx</span><span class="p">))</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
    <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">Y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># special treatment if low number of points is even. So far we have set Y[-N/2]=X[-N/2]</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">Nx</span><span class="p">:</span>  <span class="c1"># if downsampling</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># select the component at frequency N/2</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>  <span class="c1"># add the component of X at N/2</span>
        <span class="k">elif</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>  <span class="c1"># if upsampling</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">num</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># select the component at frequency -N/2</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># halve the component at -N/2</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># select the component at +N/2</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>  <span class="c1"># set that equal to the component at -N/2</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">Nx</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_t</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">Nx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">new_t</span>


<span class="k">def</span> <span class="nf">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample `x` along the given axis using polyphase filtering.</span>

<span class="sd">    The signal `x` is upsampled by the factor `up`, a zero-phase low-pass</span>
<span class="sd">    FIR filter is applied, and then it is downsampled by the factor `down`.</span>
<span class="sd">    The resulting sample rate is ``up / down`` times the original sample</span>
<span class="sd">    rate. Values beyond the boundary of the signal are assumed to be zero</span>
<span class="sd">    during the filtering step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The data to be resampled.</span>
<span class="sd">    up : int</span>
<span class="sd">        The upsampling factor.</span>
<span class="sd">    down : int</span>
<span class="sd">        The downsampling factor.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` that is resampled. Default is 0.</span>
<span class="sd">    window : string, tuple, or array_like, optional</span>
<span class="sd">        Desired window to use to design the low-pass filter, or the FIR filter</span>
<span class="sd">        coefficients to employ. See below for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    resampled_x : array</span>
<span class="sd">        The resampled array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    decimate : Downsample the signal after applying an FIR or IIR filter.</span>
<span class="sd">    resample : Resample up or down using the FFT method.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This polyphase method will likely be faster than the Fourier method</span>
<span class="sd">    in `scipy.signal.resample` when the number of samples is large and</span>
<span class="sd">    prime, or when the number of samples is large and `up` and `down`</span>
<span class="sd">    share a large greatest common denominator. The length of the FIR</span>
<span class="sd">    filter used will depend on ``max(up, down) // gcd(up, down)``, and</span>
<span class="sd">    the number of operations during polyphase filtering will depend on</span>
<span class="sd">    the filter length and `down` (see `scipy.signal.upfirdn` for details).</span>

<span class="sd">    The argument `window` specifies the FIR low-pass filter design.</span>

<span class="sd">    If `window` is an array_like it is assumed to be the FIR filter</span>
<span class="sd">    coefficients. Note that the FIR filter is applied after the upsampling</span>
<span class="sd">    step, so it should be designed to operate on a signal at a sampling</span>
<span class="sd">    frequency higher than the original by a factor of `up//gcd(up, down)`.</span>
<span class="sd">    This function&#39;s output will be centered with respect to this array, so it</span>
<span class="sd">    is best to pass a symmetric filter with an odd number of samples if, as</span>
<span class="sd">    is usually the case, a zero-phase filter is desired.</span>

<span class="sd">    For any other type of `window`, the functions `scipy.signal.get_window`</span>
<span class="sd">    and `scipy.signal.firwin` are called to generate the appropriate filter</span>
<span class="sd">    coefficients.</span>

<span class="sd">    The first sample of the returned vector is the same as the first</span>
<span class="sd">    sample of the input vector. The spacing between samples is changed</span>
<span class="sd">    from ``dx`` to ``dx * down / float(up)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Note that the end of the resampled data rises to meet the first</span>
<span class="sd">    sample of the next cycle for the FFT method, and gets closer to zero</span>
<span class="sd">    for the polyphase method:</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 10, 20, endpoint=False)</span>
<span class="sd">    &gt;&gt;&gt; y = np.cos(-x**2/6.0)</span>
<span class="sd">    &gt;&gt;&gt; f_fft = signal.resample(y, 100)</span>
<span class="sd">    &gt;&gt;&gt; f_poly = signal.resample_poly(y, 100, 20)</span>
<span class="sd">    &gt;&gt;&gt; xnew = np.linspace(0, 10, 100, endpoint=False)</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xnew, f_fft, &#39;b.-&#39;, xnew, f_poly, &#39;r.-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;ko-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(10, y[0], &#39;bo&#39;, 10, 0., &#39;ro&#39;)  # boundaries</span>
<span class="sd">    &gt;&gt;&gt; plt.legend([&#39;resample&#39;, &#39;resamp_poly&#39;, &#39;data&#39;], loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">up</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">up</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;up must be an integer&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">down</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;down must be an integer&quot;</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">up</span><span class="p">)</span>
    <span class="n">down</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">down</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">up</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">down</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;up and down must be &gt;= 1&#39;</span><span class="p">)</span>

    <span class="c1"># Determine our up and down factors</span>
    <span class="c1"># Use a rational approimation to save computation time on really long</span>
    <span class="c1"># signals</span>
    <span class="n">g_</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">//=</span> <span class="n">g_</span>
    <span class="n">down</span> <span class="o">//=</span> <span class="n">g_</span>
    <span class="k">if</span> <span class="n">up</span> <span class="o">==</span> <span class="n">down</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n_out</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">up</span>
    <span class="n">n_out</span> <span class="o">=</span> <span class="n">n_out</span> <span class="o">//</span> <span class="n">down</span> <span class="o">+</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n_out</span> <span class="o">%</span> <span class="n">down</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>  <span class="c1"># use array to force a copy (we modify it)</span>
        <span class="k">if</span> <span class="n">window</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;window must be 1-D&#39;</span><span class="p">)</span>
        <span class="n">half_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Design a linear-phase low-pass FIR filter</span>
        <span class="n">max_rate</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
        <span class="n">f_c</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">max_rate</span>  <span class="c1"># cutoff of FIR filter (rel. to Nyquist)</span>
        <span class="n">half_len</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">max_rate</span>  <span class="c1"># reasonable cutoff for our sinc-like function</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">half_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f_c</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">*=</span> <span class="n">up</span>

    <span class="c1"># Zero-pad our filter to put the output samples at the center</span>
    <span class="n">n_pre_pad</span> <span class="o">=</span> <span class="p">(</span><span class="n">down</span> <span class="o">-</span> <span class="n">half_len</span> <span class="o">%</span> <span class="n">down</span><span class="p">)</span>
    <span class="n">n_post_pad</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_pre_remove</span> <span class="o">=</span> <span class="p">(</span><span class="n">half_len</span> <span class="o">+</span> <span class="n">n_pre_pad</span><span class="p">)</span> <span class="o">//</span> <span class="n">down</span>
    <span class="c1"># We should rarely need to do this given our filter lengths...</span>
    <span class="k">while</span> <span class="n">_output_len</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_pre_pad</span> <span class="o">+</span> <span class="n">n_post_pad</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
                      <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_out</span> <span class="o">+</span> <span class="n">n_pre_remove</span><span class="p">:</span>
        <span class="n">n_post_pad</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pre_pad</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_post_pad</span><span class="p">)))</span>
    <span class="n">n_pre_remove_end</span> <span class="o">=</span> <span class="n">n_pre_remove</span> <span class="o">+</span> <span class="n">n_out</span>

    <span class="c1"># filter then remove excess</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">upfirdn</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">keep</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">n_pre_remove</span><span class="p">,</span> <span class="n">n_pre_remove_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">vectorstrength</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">period</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine the vector strength of the events corresponding to the given</span>
<span class="sd">    period.</span>

<span class="sd">    The vector strength is a measure of phase synchrony, how well the</span>
<span class="sd">    timing of the events is synchronized to a single period of a periodic</span>
<span class="sd">    signal.</span>

<span class="sd">    If multiple periods are used, calculate the vector strength of each.</span>
<span class="sd">    This is called the &quot;resonating vector strength&quot;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    events : 1D array_like</span>
<span class="sd">        An array of time points containing the timing of the events.</span>
<span class="sd">    period : float or array_like</span>
<span class="sd">        The period of the signal that the events should synchronize to.</span>
<span class="sd">        The period is in the same units as `events`.  It can also be an array</span>
<span class="sd">        of periods, in which case the outputs are arrays of the same length.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    strength : float or 1D array</span>
<span class="sd">        The strength of the synchronization.  1.0 is perfect synchronization</span>
<span class="sd">        and 0.0 is no synchronization.  If `period` is an array, this is also</span>
<span class="sd">        an array with each element containing the vector strength at the</span>
<span class="sd">        corresponding period.</span>
<span class="sd">    phase : float or array</span>
<span class="sd">        The phase that the events are most strongly synchronized to in radians.</span>
<span class="sd">        If `period` is an array, this is also an array with each element</span>
<span class="sd">        containing the phase for the corresponding period.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    van Hemmen, JL, Longtin, A, and Vollmayr, AN. Testing resonating vector</span>
<span class="sd">        strength: Auditory system, electric fish, and noise.</span>
<span class="sd">        Chaos 21, 047508 (2011);</span>
<span class="sd">        :doi:`10.1063/1.3670512`.</span>
<span class="sd">    van Hemmen, JL.  Vector strength after Goldberg, Brown, and von Mises:</span>
<span class="sd">        biological and mathematical perspectives.  Biol Cybern.</span>
<span class="sd">        2013 Aug;107(4):385-96. :doi:`10.1007/s00422-013-0561-7`.</span>
<span class="sd">    van Hemmen, JL and Vollmayr, AN.  Resonating vector strength: what happens</span>
<span class="sd">        when we vary the &quot;probing&quot; frequency while keeping the spike times</span>
<span class="sd">        fixed.  Biol Cybern. 2013 Aug;107(4):491-94.</span>
<span class="sd">        :doi:`10.1007/s00422-013-0560-8`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;events cannot have dimensions more than 1&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">period</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;period cannot have dimensions more than 1&#39;</span><span class="p">)</span>

    <span class="c1"># we need to know later if period was originally a scalar</span>
    <span class="n">scalarperiod</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">period</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;periods must be positive&#39;</span><span class="p">)</span>

    <span class="c1"># this converts the times to vectors</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">period</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">events</span><span class="p">))</span>

    <span class="c1"># the vector strength is just the magnitude of the mean of the vectors</span>
    <span class="c1"># the vector phase is the angle of the mean of the vectors</span>
    <span class="n">vectormean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">vectors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">strength</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vectormean</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vectormean</span><span class="p">)</span>

    <span class="c1"># if the original period was a scalar, return scalars</span>
    <span class="k">if</span> <span class="n">scalarperiod</span><span class="p">:</span>
        <span class="n">strength</span> <span class="o">=</span> <span class="n">strength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">strength</span><span class="p">,</span> <span class="n">phase</span>


<span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">bp</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove linear trend along axis from data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        The input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to detrend the data. By default this is the</span>
<span class="sd">        last axis (-1).</span>
<span class="sd">    type : {&#39;linear&#39;, &#39;constant&#39;}, optional</span>
<span class="sd">        The type of detrending. If ``type == &#39;linear&#39;`` (default),</span>
<span class="sd">        the result of a linear least-squares fit to `data` is subtracted</span>
<span class="sd">        from `data`.</span>
<span class="sd">        If ``type == &#39;constant&#39;``, only the mean of `data` is subtracted.</span>
<span class="sd">    bp : array_like of ints, optional</span>
<span class="sd">        A sequence of break points. If given, an individual linear fit is</span>
<span class="sd">        performed for each part of `data` between two break points.</span>
<span class="sd">        Break points are specified as indices into `data`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : ndarray</span>
<span class="sd">        The detrended input data.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; randgen = np.random.RandomState(9)</span>
<span class="sd">    &gt;&gt;&gt; npoints = 1000</span>
<span class="sd">    &gt;&gt;&gt; noise = randgen.randn(npoints)</span>
<span class="sd">    &gt;&gt;&gt; x = 3 + 2*np.linspace(0, 1, npoints) + noise</span>
<span class="sd">    &gt;&gt;&gt; (signal.detrend(x) - noise).max() &lt; 0.01</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trend type must be &#39;linear&#39; or &#39;constant&#39;.&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;dfDF&#39;</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dshape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">dshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">N</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bp</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Breakpoints must be less than length &quot;</span>
                             <span class="s2">&quot;of data along given axis.&quot;</span><span class="p">)</span>
        <span class="n">Nreg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bp</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Restructure data so that axis is along first dimension and</span>
        <span class="c1">#  all other dimensions are collapsed into second dimension</span>
        <span class="n">rnk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">rnk</span>
        <span class="n">newdims</span> <span class="o">=</span> <span class="n">r_</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">axis</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">rnk</span><span class="p">]</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newdims</span><span class="p">)),</span>
                          <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">_prod</span><span class="p">(</span><span class="n">dshape</span><span class="p">)</span> <span class="o">//</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="n">newdata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># make sure we have a copy</span>
        <span class="k">if</span> <span class="n">newdata</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;dfDF&#39;</span><span class="p">:</span>
            <span class="n">newdata</span> <span class="o">=</span> <span class="n">newdata</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Find leastsq fit and remove it for each piece</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nreg</span><span class="p">):</span>
            <span class="n">Npts</span> <span class="o">=</span> <span class="n">bp</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">ones</span><span class="p">((</span><span class="n">Npts</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="n">A</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">[</span><span class="n">dtype</span><span class="p">](</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Npts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Npts</span><span class="p">)</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">bp</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">bp</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">coef</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">newdata</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>
            <span class="n">newdata</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">=</span> <span class="n">newdata</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
        <span class="c1"># Put data back in original shape.</span>
        <span class="n">tdshape</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">dshape</span><span class="p">,</span> <span class="n">newdims</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">newdata</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tdshape</span><span class="p">))</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rnk</span><span class="p">))</span>
        <span class="n">olddims</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="n">axis</span><span class="p">:]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">olddims</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span> <span class="nf">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct initial conditions for lfilter for step response steady-state.</span>

<span class="sd">    Compute an initial state `zi` for the `lfilter` function that corresponds</span>
<span class="sd">    to the steady state of the step response.</span>

<span class="sd">    A typical use of this function is to set the initial state so that the</span>
<span class="sd">    output of the filter starts at the same value as the first element of</span>
<span class="sd">    the signal to be filtered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b, a : array_like (1-D)</span>
<span class="sd">        The IIR filter coefficients. See `lfilter` for more</span>
<span class="sd">        information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zi : 1-D ndarray</span>
<span class="sd">        The initial state for the filter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lfilter, lfiltic, filtfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A linear filter with order m has a state space representation (A, B, C, D),</span>
<span class="sd">    for which the output y of the filter can be expressed as::</span>

<span class="sd">        z(n+1) = A*z(n) + B*x(n)</span>
<span class="sd">        y(n)   = C*z(n) + D*x(n)</span>

<span class="sd">    where z(n) is a vector of length m, A has shape (m, m), B has shape</span>
<span class="sd">    (m, 1), C has shape (1, m) and D has shape (1, 1) (assuming x(n) is</span>
<span class="sd">    a scalar).  lfilter_zi solves::</span>

<span class="sd">        zi = A*zi + B</span>

<span class="sd">    In other words, it finds the initial condition for which the response</span>
<span class="sd">    to an input of all ones is a constant.</span>

<span class="sd">    Given the filter coefficients `a` and `b`, the state space matrices</span>
<span class="sd">    for the transposed direct form II implementation of the linear filter,</span>
<span class="sd">    which is the implementation used by scipy.signal.lfilter, are::</span>

<span class="sd">        A = scipy.linalg.companion(a).T</span>
<span class="sd">        B = b[1:] - a[1:]*b[0]</span>

<span class="sd">    assuming `a[0]` is 1.0; if `a[0]` is not 1, `a` and `b` are first</span>
<span class="sd">    divided by a[0].</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The following code creates a lowpass Butterworth filter. Then it</span>
<span class="sd">    applies that filter to an array whose values are all 1.0; the</span>
<span class="sd">    output is also all 1.0, as expected for a lowpass filter.  If the</span>
<span class="sd">    `zi` argument of `lfilter` had not been given, the output would have</span>
<span class="sd">    shown the transient signal.</span>

<span class="sd">    &gt;&gt;&gt; from numpy import array, ones</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import lfilter, lfilter_zi, butter</span>
<span class="sd">    &gt;&gt;&gt; b, a = butter(5, 0.25)</span>
<span class="sd">    &gt;&gt;&gt; zi = lfilter_zi(b, a)</span>
<span class="sd">    &gt;&gt;&gt; y, zo = lfilter(b, a, ones(10), zi=zi)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])</span>

<span class="sd">    Another example:</span>

<span class="sd">    &gt;&gt;&gt; x = array([0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.0])</span>
<span class="sd">    &gt;&gt;&gt; y, zf = lfilter(b, a, x, zi=zi*x[0])</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([ 0.5       ,  0.5       ,  0.5       ,  0.49836039,  0.48610528,</span>
<span class="sd">        0.44399389,  0.35505241])</span>

<span class="sd">    Note that the `zi` argument to `lfilter` was computed using</span>
<span class="sd">    `lfilter_zi` and scaled by `x[0]`.  Then the output `y` has no</span>
<span class="sd">    transient until the input drops from 0.5 to 0.0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># FIXME: Can this function be replaced with an appropriate</span>
    <span class="c1"># use of lfiltic?  For example, when b,a = butter(N,Wn),</span>
    <span class="c1">#    lfiltic(b, a, y=numpy.ones_like(a), x=numpy.ones_like(b)).</span>
    <span class="c1">#</span>

    <span class="c1"># We could use scipy.signal.normalize, but it uses warnings in</span>
    <span class="c1"># cases where a ValueError is more appropriate, and it allows</span>
    <span class="c1"># b to be 2D.</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Numerator b must be 1-D.&quot;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Denominator a must be 1-D.&quot;</span><span class="p">)</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be at least one nonzero `a` coefficient.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># Normalize the coefficients so a[0] == 1.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="c1"># Pad a or b with zeros so they are the same length.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))]</span>

    <span class="n">IminusA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">linalg</span><span class="o">.</span><span class="n">companion</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Solve zi = A*zi + B</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">IminusA</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>

    <span class="c1"># For future reference: we could also use the following</span>
    <span class="c1"># explicit formulas to solve the linear system:</span>
    <span class="c1">#</span>
    <span class="c1"># zi = np.zeros(n - 1)</span>
    <span class="c1"># zi[0] = B.sum() / IminusA[:,0].sum()</span>
    <span class="c1"># asum = 1.0</span>
    <span class="c1"># csum = 0.0</span>
    <span class="c1"># for k in range(1,n-1):</span>
    <span class="c1">#     asum += a[k]</span>
    <span class="c1">#     csum += b[k] - a[k]*b[0]</span>
    <span class="c1">#     zi[k] = asum*zi[0] - csum</span>

    <span class="k">return</span> <span class="n">zi</span>


<span class="k">def</span> <span class="nf">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct initial conditions for sosfilt for step response steady-state.</span>

<span class="sd">    Compute an initial state `zi` for the `sosfilt` function that corresponds</span>
<span class="sd">    to the steady state of the step response.</span>

<span class="sd">    A typical use of this function is to set the initial state so that the</span>
<span class="sd">    output of the filter starts at the same value as the first element of</span>
<span class="sd">    the signal to be filtered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. See `sosfilt` for the SOS filter format</span>
<span class="sd">        specification.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zi : ndarray</span>
<span class="sd">        Initial conditions suitable for use with ``sosfilt``, shape</span>
<span class="sd">        ``(n_sections, 2)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sosfilt, zpk2sos</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Filter a rectangular pulse that begins at time 0, with and without</span>
<span class="sd">    the use of the `zi` argument of `scipy.signal.sosfilt`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    &gt;&gt;&gt; sos = signal.butter(9, 0.125, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zi = signal.sosfilt_zi(sos)</span>
<span class="sd">    &gt;&gt;&gt; x = (np.arange(250) &lt; 100).astype(int)</span>
<span class="sd">    &gt;&gt;&gt; f1 = signal.sosfilt(sos, x)</span>
<span class="sd">    &gt;&gt;&gt; f2, zo = signal.sosfilt(sos, x, zi=zi)</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(x, &#39;k--&#39;, label=&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(f1, &#39;b&#39;, alpha=0.5, linewidth=2, label=&#39;filtered&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(f2, &#39;g&#39;, alpha=0.25, linewidth=4, label=&#39;filtered with zi&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sos must be shape (n_sections, 6)&#39;</span><span class="p">)</span>

    <span class="n">n_sections</span> <span class="o">=</span> <span class="n">sos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_sections</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span>
        <span class="n">zi</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="c1"># If H(z) = B(z)/A(z) is this section&#39;s transfer function, then</span>
        <span class="c1"># b.sum()/a.sum() is H(1), the gain at omega=0.  That&#39;s the steady</span>
        <span class="c1"># state value of this section&#39;s step response.</span>
        <span class="n">scale</span> <span class="o">*=</span> <span class="n">b</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">zi</span>


<span class="k">def</span> <span class="nf">_filtfilt_gust</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">irlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forward-backward IIR filter that uses Gustafsson&#39;s method.</span>

<span class="sd">    Apply the IIR filter defined by `(b,a)` to `x` twice, first forward</span>
<span class="sd">    then backward, using Gustafsson&#39;s initial conditions [1]_.</span>

<span class="sd">    Let ``y_fb`` be the result of filtering first forward and then backward,</span>
<span class="sd">    and let ``y_bf`` be the result of filtering first backward then forward.</span>
<span class="sd">    Gustafsson&#39;s method is to compute initial conditions for the forward</span>
<span class="sd">    pass and the backward pass such that ``y_fb == y_bf``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : scalar or 1-D ndarray</span>
<span class="sd">        Numerator coefficients of the filter.</span>
<span class="sd">    a : scalar or 1-D ndarray</span>
<span class="sd">        Denominator coefficients of the filter.</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Data to be filtered.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis of `x` to be filtered.  Default is -1.</span>
<span class="sd">    irlen : int or None, optional</span>
<span class="sd">        The length of the nonnegligible part of the impulse response.</span>
<span class="sd">        If `irlen` is None, or if the length of the signal is less than</span>
<span class="sd">        ``2 * irlen``, then no part of the impulse response is ignored.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The filtered data.</span>
<span class="sd">    x0 : ndarray</span>
<span class="sd">        Initial condition for the forward filter.</span>
<span class="sd">    x1 : ndarray</span>
<span class="sd">        Initial condition for the backward filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Typically the return values `x0` and `x1` are not needed by the</span>
<span class="sd">    caller.  The intended use of these return values is in unit tests.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] F. Gustaffson. Determining the initial states in forward-backward</span>
<span class="sd">           filtering. Transactions on Signal Processing, 46(4):988-992, 1996.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In the comments, &quot;Gustafsson&#39;s paper&quot; and [1] refer to the</span>
    <span class="c1"># paper referenced in the docstring.</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># The filter is just scalar multiplication, with no state.</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Move the axis containing the data to the end.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># n is the number of samples in the data to be filtered.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">irlen</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">irlen</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">irlen</span>

    <span class="c1"># Create Obs, the observability matrix (called O in the paper).</span>
    <span class="c1"># This matrix can be interpreted as the operator that propagates</span>
    <span class="c1"># an arbitrary initial state to the output, assuming the input is</span>
    <span class="c1"># zero.</span>
    <span class="c1"># In Gustafsson&#39;s paper, the forward and backward filters are not</span>
    <span class="c1"># necessarily the same, so he has both O_f and O_b.  We use the same</span>
    <span class="c1"># filter in both directions, so we only need O. The same comment</span>
    <span class="c1"># applies to S below.</span>
    <span class="n">Obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="n">zi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Obs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">Obs</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Obs</span><span class="p">[:</span><span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Obsr is O^R (Gustafsson&#39;s notation for row-reversed O)</span>
    <span class="n">Obsr</span> <span class="o">=</span> <span class="n">Obs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Create S.  S is the matrix that applies the filter to the reversed</span>
    <span class="c1"># propagated initial conditions.  That is,</span>
    <span class="c1">#     out = S.dot(zi)</span>
    <span class="c1"># is the same as</span>
    <span class="c1">#     tmp, _ = lfilter(b, a, zeros(), zi=zi)  # Propagate ICs.</span>
    <span class="c1">#     out = lfilter(b, a, tmp[::-1])          # Reverse and filter.</span>

    <span class="c1"># Equations (5) &amp; (6) of [1]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">Obs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Sr is S^R (row-reversed S)</span>
    <span class="n">Sr</span> <span class="o">=</span> <span class="n">S</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># M is [(S^R - O), (O^R - S)]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Sr</span> <span class="o">-</span> <span class="n">Obs</span><span class="p">,</span> <span class="n">Obsr</span> <span class="o">-</span> <span class="n">S</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Matrix described in section IV of [1].</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">))</span>
        <span class="n">M</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sr</span> <span class="o">-</span> <span class="n">Obs</span>
        <span class="n">M</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="n">order</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Obsr</span> <span class="o">-</span> <span class="n">S</span>

    <span class="c1"># Naive forward-backward and backward-forward filters.</span>
    <span class="c1"># These have large transients because the filters use zero initial</span>
    <span class="c1"># conditions.</span>
    <span class="n">y_f</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y_fb</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">y_f</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">y_b</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y_bf</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">y_b</span><span class="p">)</span>

    <span class="n">delta_y_bf_fb</span> <span class="o">=</span> <span class="n">y_bf</span> <span class="o">-</span> <span class="n">y_fb</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">delta_y_bf_fb</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start_m</span> <span class="o">=</span> <span class="n">delta_y_bf_fb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
        <span class="n">end_m</span> <span class="o">=</span> <span class="n">delta_y_bf_fb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">:]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">start_m</span><span class="p">,</span> <span class="n">end_m</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># ic_opt holds the &quot;optimal&quot; initial conditions.</span>
    <span class="c1"># The following code computes the result shown in the formula</span>
    <span class="c1"># of the paper between equations (6) and (7).</span>
    <span class="k">if</span> <span class="n">delta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ic_opt</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">delta</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Reshape delta so it can be used as an array of multiple</span>
        <span class="c1"># right-hand-sides in linalg.lstsq.</span>
        <span class="n">delta2d</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ic_opt0</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">delta2d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">ic_opt</span> <span class="o">=</span> <span class="n">ic_opt0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],))</span>

    <span class="c1"># Now compute the filtered signal using equation (7) of [1].</span>
    <span class="c1"># First, form [S^R, O^R] and call it W.</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">Sr</span><span class="p">,</span> <span class="n">Obsr</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">))</span>
        <span class="n">W</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sr</span>
        <span class="n">W</span><span class="p">[</span><span class="n">m</span><span class="p">:,</span> <span class="n">order</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Obsr</span>

    <span class="c1"># Equation (7) of [1] says</span>
    <span class="c1">#     Y_fb^opt = Y_fb^0 + W * [x_0^opt; x_{N-1}^opt]</span>
    <span class="c1"># `wic` is (almost) the product on the right.</span>
    <span class="c1"># W has shape (m, 2*order), and ic_opt has shape (..., 2*order),</span>
    <span class="c1"># so we can&#39;t use W.dot(ic_opt).  Instead, we dot ic_opt with W.T,</span>
    <span class="c1"># so wic has shape (..., m).</span>
    <span class="n">wic</span> <span class="o">=</span> <span class="n">ic_opt</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># `wic` is &quot;almost&quot; the product of W and the optimal ICs in equation</span>
    <span class="c1"># (7)--if we&#39;re using a truncated impulse response (m &lt; n), `wic`</span>
    <span class="c1"># contains only the adjustments required for the ends of the signal.</span>
    <span class="c1"># Here we form y_opt, taking this into account if necessary.</span>
    <span class="n">y_opt</span> <span class="o">=</span> <span class="n">y_fb</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">y_opt</span> <span class="o">+=</span> <span class="n">wic</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">wic</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
        <span class="n">y_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">wic</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">m</span><span class="p">:]</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">ic_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">ic_opt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">order</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Restore the data axis to its original position.</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">y_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">y_opt</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y_opt</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span>


<span class="k">def</span> <span class="nf">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="n">padlen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span>
             <span class="n">irlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a digital filter forward and backward to a signal.</span>

<span class="sd">    This function applies a linear digital filter twice, once forward and</span>
<span class="sd">    once backwards.  The combined filter has zero phase and a filter order</span>
<span class="sd">    twice that of the original.</span>

<span class="sd">    The function provides options for handling the edges of the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b : (N,) array_like</span>
<span class="sd">        The numerator coefficient vector of the filter.</span>
<span class="sd">    a : (N,) array_like</span>
<span class="sd">        The denominator coefficient vector of the filter.  If ``a[0]``</span>
<span class="sd">        is not 1, then both `a` and `b` are normalized by ``a[0]``.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The array of data to be filtered.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` to which the filter is applied.</span>
<span class="sd">        Default is -1.</span>
<span class="sd">    padtype : str or None, optional</span>
<span class="sd">        Must be &#39;odd&#39;, &#39;even&#39;, &#39;constant&#39;, or None.  This determines the</span>
<span class="sd">        type of extension to use for the padded signal to which the filter</span>
<span class="sd">        is applied.  If `padtype` is None, no padding is used.  The default</span>
<span class="sd">        is &#39;odd&#39;.</span>
<span class="sd">    padlen : int or None, optional</span>
<span class="sd">        The number of elements by which to extend `x` at both ends of</span>
<span class="sd">        `axis` before applying the filter.  This value must be less than</span>
<span class="sd">        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.</span>
<span class="sd">        The default value is ``3 * max(len(a), len(b))``.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Determines the method for handling the edges of the signal, either</span>
<span class="sd">        &quot;pad&quot; or &quot;gust&quot;.  When `method` is &quot;pad&quot;, the signal is padded; the</span>
<span class="sd">        type of padding is determined by `padtype` and `padlen`, and `irlen`</span>
<span class="sd">        is ignored.  When `method` is &quot;gust&quot;, Gustafsson&#39;s method is used,</span>
<span class="sd">        and `padtype` and `padlen` are ignored.</span>
<span class="sd">    irlen : int or None, optional</span>
<span class="sd">        When `method` is &quot;gust&quot;, `irlen` specifies the length of the</span>
<span class="sd">        impulse response of the filter.  If `irlen` is None, no part</span>
<span class="sd">        of the impulse response is ignored.  For a long signal, specifying</span>
<span class="sd">        `irlen` can significantly improve the performance of the filter.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The filtered output with the same shape as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sosfiltfilt, lfilter_zi, lfilter, lfiltic, savgol_filter, sosfilt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When `method` is &quot;pad&quot;, the function pads the data along the given axis</span>
<span class="sd">    in one of three ways: odd, even or constant.  The odd and even extensions</span>
<span class="sd">    have the corresponding symmetry about the end point of the data.  The</span>
<span class="sd">    constant extension extends the data with the values at the end points. On</span>
<span class="sd">    both the forward and backward passes, the initial condition of the</span>
<span class="sd">    filter is found by using `lfilter_zi` and scaling it by the end point of</span>
<span class="sd">    the extended data.</span>

<span class="sd">    When `method` is &quot;gust&quot;, Gustafsson&#39;s method [1]_ is used.  Initial</span>
<span class="sd">    conditions are chosen for the forward and backward passes so that the</span>
<span class="sd">    forward-backward filter gives the same result as the backward-forward</span>
<span class="sd">    filter.</span>

<span class="sd">    The option to use Gustaffson&#39;s method was added in scipy version 0.16.0.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] F. Gustaffson, &quot;Determining the initial states in forward-backward</span>
<span class="sd">           filtering&quot;, Transactions on Signal Processing, Vol. 46, pp. 988-992,</span>
<span class="sd">           1996.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The examples will use several functions from `scipy.signal`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    First we create a one second signal that is the sum of two pure sine</span>
<span class="sd">    waves, with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.</span>

<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1.0, 2001)</span>
<span class="sd">    &gt;&gt;&gt; xlow = np.sin(2 * np.pi * 5 * t)</span>
<span class="sd">    &gt;&gt;&gt; xhigh = np.sin(2 * np.pi * 250 * t)</span>
<span class="sd">    &gt;&gt;&gt; x = xlow + xhigh</span>

<span class="sd">    Now create a lowpass Butterworth filter with a cutoff of 0.125 times</span>
<span class="sd">    the Nyquist rate, or 125 Hz, and apply it to ``x`` with `filtfilt`.</span>
<span class="sd">    The result should be approximately ``xlow``, with no phase shift.</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.butter(8, 0.125)</span>
<span class="sd">    &gt;&gt;&gt; y = signal.filtfilt(b, a, x, padlen=150)</span>
<span class="sd">    &gt;&gt;&gt; np.abs(y - xlow).max()</span>
<span class="sd">    9.1086182074789912e-06</span>

<span class="sd">    We get a fairly clean result for this artificial example because</span>
<span class="sd">    the odd extension is exact, and with the moderately long padding,</span>
<span class="sd">    the filter&#39;s transients have dissipated by the time the actual data</span>
<span class="sd">    is reached.  In general, transient effects at the edges are</span>
<span class="sd">    unavoidable.</span>

<span class="sd">    The following example demonstrates the option ``method=&quot;gust&quot;``.</span>

<span class="sd">    First, create a filter.</span>

<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(4, 0.01, 120, 0.125)  # Filter to be applied.</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(123456)</span>

<span class="sd">    `sig` is a random input signal to be filtered.</span>

<span class="sd">    &gt;&gt;&gt; n = 60</span>
<span class="sd">    &gt;&gt;&gt; sig = np.random.randn(n)**3 + 3*np.random.randn(n).cumsum()</span>

<span class="sd">    Apply `filtfilt` to `sig`, once using the Gustafsson method, and</span>
<span class="sd">    once using padding, and plot the results for comparison.</span>

<span class="sd">    &gt;&gt;&gt; fgust = signal.filtfilt(b, a, sig, method=&quot;gust&quot;)</span>
<span class="sd">    &gt;&gt;&gt; fpad = signal.filtfilt(b, a, sig, padlen=50)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(sig, &#39;k-&#39;, label=&#39;input&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(fgust, &#39;b-&#39;, linewidth=4, label=&#39;gust&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(fpad, &#39;c-&#39;, linewidth=1.5, label=&#39;pad&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    The `irlen` argument can be used to improve the performance</span>
<span class="sd">    of Gustafsson&#39;s method.</span>

<span class="sd">    Estimate the impulse response length of the filter.</span>

<span class="sd">    &gt;&gt;&gt; z, p, k = signal.tf2zpk(b, a)</span>
<span class="sd">    &gt;&gt;&gt; eps = 1e-9</span>
<span class="sd">    &gt;&gt;&gt; r = np.max(np.abs(p))</span>
<span class="sd">    &gt;&gt;&gt; approx_impulse_len = int(np.ceil(np.log(eps) / np.log(r)))</span>
<span class="sd">    &gt;&gt;&gt; approx_impulse_len</span>
<span class="sd">    137</span>

<span class="sd">    Apply the filter to a longer signal, with and without the `irlen`</span>
<span class="sd">    argument.  The difference between `y1` and `y2` is small.  For long</span>
<span class="sd">    signals, using `irlen` gives a significant performance improvement.</span>

<span class="sd">    &gt;&gt;&gt; x = np.random.randn(5000)</span>
<span class="sd">    &gt;&gt;&gt; y1 = signal.filtfilt(b, a, x, method=&#39;gust&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y2 = signal.filtfilt(b, a, x, method=&#39;gust&#39;, irlen=approx_impulse_len)</span>
<span class="sd">    &gt;&gt;&gt; print(np.max(np.abs(y1 - y2)))</span>
<span class="sd">    1.80056858312e-10</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;gust&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;pad&#39; or &#39;gust&#39;.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gust&quot;</span><span class="p">:</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">_filtfilt_gust</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">irlen</span><span class="o">=</span><span class="n">irlen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span>

    <span class="c1"># method == &quot;pad&quot;</span>
    <span class="n">edge</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">_validate_pad</span><span class="p">(</span><span class="n">padtype</span><span class="p">,</span> <span class="n">padlen</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                              <span class="n">ntaps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

    <span class="c1"># Get the steady state of the filter&#39;s step response.</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">lfilter_zi</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="c1"># Reshape zi and create x0 so that zi*x0 broadcasts</span>
    <span class="c1"># to the correct value for the &#39;zi&#39; keyword argument</span>
    <span class="c1"># to lfilter.</span>
    <span class="n">zi_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">zi_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">zi</span><span class="o">.</span><span class="n">size</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">zi_shape</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="c1"># Forward filter.</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">x0</span><span class="p">)</span>

    <span class="c1"># Backward filter.</span>
    <span class="c1"># Create y0 so zi*y0 broadcasts appropriately.</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">y0</span><span class="p">)</span>

    <span class="c1"># Reverse y.</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Slice the actual signal from the extended signal.</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">_validate_pad</span><span class="p">(</span><span class="n">padtype</span><span class="p">,</span> <span class="n">padlen</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ntaps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to validate padding for filtfilt&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;even&#39;</span><span class="p">,</span> <span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s2">&quot;Unknown value &#39;</span><span class="si">%s</span><span class="s2">&#39; given to padtype.  padtype &quot;</span>
                          <span class="s2">&quot;must be &#39;even&#39;, &#39;odd&#39;, &#39;constant&#39;, or None.&quot;</span><span class="p">)</span> <span class="o">%</span>
                         <span class="n">padtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">padlen</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">padlen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Original padding; preserved for backwards compatibility.</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">ntaps</span> <span class="o">*</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">padlen</span>

    <span class="c1"># x&#39;s &#39;axis&#39; dimension must be bigger than edge.</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">edge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of the input vector x must be at least &quot;</span>
                         <span class="s2">&quot;padlen, which is </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">edge</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">padtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Make an extension of length `edge` at each</span>
        <span class="c1"># end of the input array.</span>
        <span class="k">if</span> <span class="n">padtype</span> <span class="o">==</span> <span class="s1">&#39;even&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">even_ext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">padtype</span> <span class="o">==</span> <span class="s1">&#39;odd&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">odd_ext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="n">const_ext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">edge</span><span class="p">,</span> <span class="n">ext</span>


<span class="k">def</span> <span class="nf">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter data along one dimension using cascaded second-order sections.</span>

<span class="sd">    Filter a data sequence, `x`, using a digital IIR filter defined by</span>
<span class="sd">    `sos`. This is implemented by performing `lfilter` for each</span>
<span class="sd">    second-order section.  See `lfilter` for details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. Each row corresponds to a second-order</span>
<span class="sd">        section, with the first three columns providing the numerator</span>
<span class="sd">        coefficients and the last three providing the denominator</span>
<span class="sd">        coefficients.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        An N-dimensional input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of the input data array along which to apply the</span>
<span class="sd">        linear filter. The filter is applied to each subarray along</span>
<span class="sd">        this axis.  Default is -1.</span>
<span class="sd">    zi : array_like, optional</span>
<span class="sd">        Initial conditions for the cascaded filter delays.  It is a (at</span>
<span class="sd">        least 2D) vector of shape ``(n_sections, ..., 2, ...)``, where</span>
<span class="sd">        ``..., 2, ...`` denotes the shape of `x`, but with ``x.shape[axis]``</span>
<span class="sd">        replaced by 2.  If `zi` is None or is not given then initial rest</span>
<span class="sd">        (i.e. all zeros) is assumed.</span>
<span class="sd">        Note that these initial conditions are *not* the same as the initial</span>
<span class="sd">        conditions given by `lfiltic` or `lfilter_zi`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The output of the digital filter.</span>
<span class="sd">    zf : ndarray, optional</span>
<span class="sd">        If `zi` is None, this is not returned, otherwise, `zf` holds the</span>
<span class="sd">        final filter delay values.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    zpk2sos, sos2zpk, sosfilt_zi, sosfiltfilt, sosfreqz</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The filter function is implemented as a series of second-order filters</span>
<span class="sd">    with direct-form II transposed structure. It is designed to minimize</span>
<span class="sd">    numerical precision errors for high-order filters.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Plot a 13th-order filter&#39;s impulse response using both `lfilter` and</span>
<span class="sd">    `sosfilt`, showing the instability that results from trying to do a</span>
<span class="sd">    13th-order filter in a single stage (the numerical error pushes some poles</span>
<span class="sd">    outside of the unit circle):</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy import signal</span>
<span class="sd">    &gt;&gt;&gt; b, a = signal.ellip(13, 0.009, 80, 0.05, output=&#39;ba&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sos = signal.ellip(13, 0.009, 80, 0.05, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x = signal.unit_impulse(700)</span>
<span class="sd">    &gt;&gt;&gt; y_tf = signal.lfilter(b, a, x)</span>
<span class="sd">    &gt;&gt;&gt; y_sos = signal.sosfilt(sos, x)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y_tf, &#39;r&#39;, label=&#39;TF&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(y_sos, &#39;k&#39;, label=&#39;SOS&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(loc=&#39;best&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">sos</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">_validate_sos</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>
    <span class="n">use_zi</span> <span class="o">=</span> <span class="n">zi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">use_zi</span><span class="p">:</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
        <span class="n">x_zi_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">x_zi_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">x_zi_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">n_sections</span><span class="p">]</span> <span class="o">+</span> <span class="n">x_zi_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">x_zi_shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid zi shape. With axis=</span><span class="si">%r</span><span class="s1">, an input with &#39;</span>
                             <span class="s1">&#39;shape </span><span class="si">%r</span><span class="s1">, and an sos array with </span><span class="si">%d</span><span class="s1"> sections, zi &#39;</span>
                             <span class="s1">&#39;must have shape </span><span class="si">%r</span><span class="s1">, got </span><span class="si">%r</span><span class="s1">.&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">n_sections</span><span class="p">,</span> <span class="n">x_zi_shape</span><span class="p">,</span> <span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">zf</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sections</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">use_zi</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">zf</span><span class="p">[</span><span class="n">section</span><span class="p">]</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span>
                                     <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span><span class="p">[</span><span class="n">section</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">sos</span><span class="p">[</span><span class="n">section</span><span class="p">,</span> <span class="mi">3</span><span class="p">:],</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_zi</span> <span class="k">else</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">padtype</span><span class="o">=</span><span class="s1">&#39;odd&#39;</span><span class="p">,</span> <span class="n">padlen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A forward-backward digital filter using cascaded second-order sections.</span>

<span class="sd">    See `filtfilt` for more complete information about this method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sos : array_like</span>
<span class="sd">        Array of second-order filter coefficients, must have shape</span>
<span class="sd">        ``(n_sections, 6)``. Each row corresponds to a second-order</span>
<span class="sd">        section, with the first three columns providing the numerator</span>
<span class="sd">        coefficients and the last three providing the denominator</span>
<span class="sd">        coefficients.</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The array of data to be filtered.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis of `x` to which the filter is applied.</span>
<span class="sd">        Default is -1.</span>
<span class="sd">    padtype : str or None, optional</span>
<span class="sd">        Must be &#39;odd&#39;, &#39;even&#39;, &#39;constant&#39;, or None.  This determines the</span>
<span class="sd">        type of extension to use for the padded signal to which the filter</span>
<span class="sd">        is applied.  If `padtype` is None, no padding is used.  The default</span>
<span class="sd">        is &#39;odd&#39;.</span>
<span class="sd">    padlen : int or None, optional</span>
<span class="sd">        The number of elements by which to extend `x` at both ends of</span>
<span class="sd">        `axis` before applying the filter.  This value must be less than</span>
<span class="sd">        ``x.shape[axis] - 1``.  ``padlen=0`` implies no padding.</span>
<span class="sd">        The default value is::</span>

<span class="sd">            3 * (2 * len(sos) + 1 - min((sos[:, 2] == 0).sum(),</span>
<span class="sd">                                        (sos[:, 5] == 0).sum()))</span>

<span class="sd">        The extra subtraction at the end attempts to compensate for poles</span>
<span class="sd">        and zeros at the origin (e.g. for odd-order filters) to yield</span>
<span class="sd">        equivalent estimates of `padlen` to those of `filtfilt` for</span>
<span class="sd">        second-order section filters built with `scipy.signal` functions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The filtered output with the same shape as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    filtfilt, sosfilt, sosfilt_zi, sosfreqz</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.18.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.signal import sosfiltfilt, butter</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    Create an interesting signal to filter.</span>

<span class="sd">    &gt;&gt;&gt; n = 201</span>
<span class="sd">    &gt;&gt;&gt; t = np.linspace(0, 1, n)</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(123)</span>
<span class="sd">    &gt;&gt;&gt; x = 1 + (t &lt; 0.5) - 0.25*t**2 + 0.05*np.random.randn(n)</span>

<span class="sd">    Create a lowpass Butterworth filter, and use it to filter `x`.</span>

<span class="sd">    &gt;&gt;&gt; sos = butter(4, 0.125, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = sosfiltfilt(sos, x)</span>

<span class="sd">    For comparison, apply an 8th order filter using `sosfilt`.  The filter</span>
<span class="sd">    is initialized using the mean of the first four values of `x`.</span>

<span class="sd">    &gt;&gt;&gt; from scipy.signal import sosfilt, sosfilt_zi</span>
<span class="sd">    &gt;&gt;&gt; sos8 = butter(8, 0.125, output=&#39;sos&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zi = x[:4].mean() * sosfilt_zi(sos8)</span>
<span class="sd">    &gt;&gt;&gt; y2, zo = sosfilt(sos8, x, zi=zi)</span>

<span class="sd">    Plot the results.  Note that the phase of `y` matches the input, while</span>
<span class="sd">    `y2` has a significant phase delay.</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(t, x, alpha=0.5, label=&#39;x(t)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, y, label=&#39;y(t)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(t, y2, label=&#39;y2(t)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;t&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sos</span><span class="p">,</span> <span class="n">n_sections</span> <span class="o">=</span> <span class="n">_validate_sos</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>

    <span class="c1"># `method` is &quot;pad&quot;...</span>
    <span class="n">ntaps</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_sections</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">ntaps</span> <span class="o">-=</span> <span class="nb">min</span><span class="p">((</span><span class="n">sos</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="p">(</span><span class="n">sos</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="n">edge</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">_validate_pad</span><span class="p">(</span><span class="n">padtype</span><span class="p">,</span> <span class="n">padlen</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                              <span class="n">ntaps</span><span class="o">=</span><span class="n">ntaps</span><span class="p">)</span>

    <span class="c1"># These steps follow the same form as filtfilt with modifications</span>
    <span class="n">zi</span> <span class="o">=</span> <span class="n">sosfilt_zi</span><span class="p">(</span><span class="n">sos</span><span class="p">)</span>  <span class="c1"># shape (n_sections, 2) --&gt; (n_sections, ..., 2, ...)</span>
    <span class="n">zi_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">zi_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">zi</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_sections</span><span class="p">]</span> <span class="o">+</span> <span class="n">zi_shape</span>
    <span class="n">x_0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">x_0</span><span class="p">)</span>
    <span class="n">y_0</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span> <span class="o">=</span> <span class="n">sosfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">zi</span><span class="o">=</span><span class="n">zi</span> <span class="o">*</span> <span class="n">y_0</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">axis_reverse</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">axis_slice</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="n">edge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">zero_phase</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Downsample the signal after applying an anti-aliasing filter.</span>

<span class="sd">    By default, an order 8 Chebyshev type I filter is used. A 30 point FIR</span>
<span class="sd">    filter with Hamming window is used if `ftype` is &#39;fir&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The signal to be downsampled, as an N-dimensional array.</span>
<span class="sd">    q : int</span>
<span class="sd">        The downsampling factor. When using IIR downsampling, it is recommended</span>
<span class="sd">        to call `decimate` multiple times for downsampling factors higher than</span>
<span class="sd">        13.</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        The order of the filter (1 less than the length for &#39;fir&#39;). Defaults to</span>
<span class="sd">        8 for &#39;iir&#39; and 20 times the downsampling factor for &#39;fir&#39;.</span>
<span class="sd">    ftype : str {&#39;iir&#39;, &#39;fir&#39;} or ``dlti`` instance, optional</span>
<span class="sd">        If &#39;iir&#39; or &#39;fir&#39;, specifies the type of lowpass filter. If an instance</span>
<span class="sd">        of an `dlti` object, uses that object to filter before downsampling.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to decimate.</span>
<span class="sd">    zero_phase : bool, optional</span>
<span class="sd">        Prevent phase shift by filtering with `filtfilt` instead of `lfilter`</span>
<span class="sd">        when using an IIR filter, and shifting the outputs back by the filter&#39;s</span>
<span class="sd">        group delay when using an FIR filter. The default value of ``True`` is</span>
<span class="sd">        recommended, since a phase shift is generally not desired.</span>

<span class="sd">        .. versionadded:: 0.18.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        The down-sampled signal.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    resample : Resample up or down using the FFT method.</span>
<span class="sd">    resample_poly : Resample using polyphase filtering and an FIR filter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``zero_phase`` keyword was added in 0.18.0.</span>
<span class="sd">    The possibility to use instances of ``dlti`` as ``ftype`` was added in</span>
<span class="sd">    0.18.0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;fir&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">half_len</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">q</span>  <span class="c1"># reasonable cutoff for our sinc-like function</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_len</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">q</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">),</span> <span class="mf">1.</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;iir&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">dlti</span><span class="p">(</span><span class="o">*</span><span class="n">cheby1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.8</span> <span class="o">/</span> <span class="n">q</span><span class="p">))</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">system</span><span class="o">.</span><span class="n">den</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ftype</span><span class="p">,</span> <span class="n">dlti</span><span class="p">):</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">ftype</span><span class="o">.</span><span class="n">_as_tf</span><span class="p">()</span>  <span class="c1"># Avoids copying if already in TF form</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">num</span><span class="p">,</span> <span class="n">system</span><span class="o">.</span><span class="n">den</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid ftype&#39;</span><span class="p">)</span>

    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># FIR case</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">zero_phase</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">resample_poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># upfirdn is generally faster than lfilter by a factor equal to the</span>
            <span class="c1"># downsampling factor, since it only calculates the needed outputs</span>
            <span class="n">n_out</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="n">q</span> <span class="o">+</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">upfirdn</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">up</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">down</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_out</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># IIR case</span>
        <span class="k">if</span> <span class="n">zero_phase</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Kivan Polimis, Ariel Rokem, Bryna Hazelton, The University of Washington eScience Institute.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>